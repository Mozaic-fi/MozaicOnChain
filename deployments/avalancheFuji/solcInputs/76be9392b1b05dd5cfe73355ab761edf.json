{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/gmx/ICallbackContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICallbackContract {\n    enum State { Deposit, Withdrawal, Order }\n\n    function addKey(bytes32 key, State stateOption) external;\n\n    function getKeys(State stateOption) external view returns(bytes32[] memory);\n\n    function addWithdrawalData(bytes32 withdrawalKey, uint256 lpAmount, address receiver) external;\n}"
    },
    "contracts/interfaces/gmx/IDataStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IDataStore {\n    function getUint(bytes32 key) external view returns (uint256);\n    function setUint(bytes32 key, uint256 value) external returns (uint256);\n    function removeUint(bytes32 key) external;\n    function applyDeltaToUint(bytes32 key, int256 value, string calldata errorMessage) external returns (uint256);\n    function applyDeltaToUint(bytes32 key, uint256 value) external returns (uint256);\n    function applyBoundedDeltaToUint(bytes32 key, int256 value) external returns (uint256);\n    function incrementUint(bytes32 key, uint256 value) external returns (uint256);\n    function decrementUint(bytes32 key, uint256 value) external returns (uint256);\n\n    function getInt(bytes32 key) external view returns (int256);\n    function setInt(bytes32 key, int256 value) external returns (int256);\n    function removeInt(bytes32 key) external;\n    function applyDeltaToInt(bytes32 key, int256 value) external returns (int256);\n    function incrementInt(bytes32 key, int256 value) external returns (int256);\n    function decrementInt(bytes32 key, int256 value) external returns (int256);\n\n    function getAddress(bytes32 key) external view returns (address);\n    function setAddress(bytes32 key, address value) external returns (address);\n    function removeAddress(bytes32 key) external;\n\n    function getBool(bytes32 key) external view returns (bool);\n    function setBool(bytes32 key, bool value) external returns (bool);\n    function removeBool(bytes32 key) external;\n\n    function getString(bytes32 key) external view returns (string memory);\n    function setString(bytes32 key, string calldata value) external returns (string memory);\n    function removeString(bytes32 key) external;\n\n    function getBytes32(bytes32 key) external view returns (bytes32);\n    function setBytes32(bytes32 key, bytes32 value) external returns (bytes32);\n    function removeBytes32(bytes32 key) external;\n\n    function getUintArray(bytes32 key) external view returns (uint256[] memory);\n    function setUintArray(bytes32 key, uint256[] memory value) external;\n    function removeUintArray(bytes32 key) external;\n\n    function getIntArray(bytes32 key) external view returns (int256[] memory);\n    function setIntArray(bytes32 key, int256[] memory value) external;\n    function removeIntArray(bytes32 key) external;\n\n    function getAddressArray(bytes32 key) external view returns (address[] memory);\n    function setAddressArray(bytes32 key, address[] memory value) external;\n    function removeAddressArray(bytes32 key) external;\n\n    function getBoolArray(bytes32 key) external view returns (bool[] memory);\n    function setBoolArray(bytes32 key, bool[] memory value) external;\n    function removeBoolArray(bytes32 key) external;\n\n    function getStringArray(bytes32 key) external view returns (string[] memory);\n    function setStringArray(bytes32 key, string[] memory value) external;\n    function removeStringArray(bytes32 key) external;\n\n    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory);\n    function setBytes32Array(bytes32 key, bytes32[] memory value) external;\n    function removeBytes32Array(bytes32 key) external;\n\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);\n    function getBytes32Count(bytes32 setKey) external view returns (uint256);\n    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory);\n    function addBytes32(bytes32 setKey, bytes32 value) external;\n    function removeBytes32(bytes32 setKey, bytes32 value) external;\n\n    function containsAddress(bytes32 setKey, address value) external view returns (bool);\n    function getAddressCount(bytes32 setKey) external view returns (uint256);\n    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory);\n    function addAddress(bytes32 setKey, address value) external;\n    function removeAddress(bytes32 setKey, address value) external;\n\n    function containsUint(bytes32 setKey, uint256 value) external view returns (bool);\n    function getUintCount(bytes32 setKey) external view returns (uint256);\n    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory);\n    function addUint(bytes32 setKey, uint256 value) external;\n    function removeUint(bytes32 setKey, uint256 value) external;\n}"
    },
    "contracts/interfaces/gmx/IExchangeRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"./IDataStore.sol\"; // Import the DataStore contract\n\ninterface IExchangeRouter {\n    \n    function dataStore() external view returns (IDataStore);\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n    \n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n\n    enum OrderType {\n        // @dev MarketSwap: swap token A to token B at the current market price\n        // the order will be cancelled if the minOutputAmount cannot be fulfilled\n        MarketSwap,\n        // @dev LimitSwap: swap token A to token B if the minOutputAmount can be fulfilled\n        LimitSwap,\n        // @dev MarketIncrease: increase position at the current market price\n        // the order will be cancelled if the position cannot be increased at the acceptablePrice\n        MarketIncrease,\n        // @dev LimitIncrease: increase position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitIncrease,\n        // @dev MarketDecrease: decrease position at the current market price\n        // the order will be cancelled if the position cannot be decreased at the acceptablePrice\n        MarketDecrease,\n        // @dev LimitDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitDecrease,\n        // @dev StopLossDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        StopLossDecrease,\n        // @dev Liquidation: allows liquidation of positions if the criteria for liquidation are met\n        Liquidation\n    }\n\n    enum DecreasePositionSwapType {\n        NoSwap,\n        SwapPnlTokenToCollateralToken,\n        SwapCollateralTokenToPnlToken\n    }\n\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        OrderType orderType;\n        DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bool autoCancel;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address cancellationReceiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev Wraps the specified amount of native tokens into WNT then sends the WNT to the specified address\n    function sendWnt(address receiver, uint256 amount) external payable;\n\n    // @dev Sends the given amount of tokens to the given address\n    function sendTokens(address token, address receiver, uint256 amount) external payable;\n\n    function createDeposit(\n        CreateDepositParams calldata params\n    ) external payable returns (bytes32);\n\n    function createWithdrawal(\n        CreateWithdrawalParams calldata params\n    ) external payable returns (bytes32);\n\n    function createOrder(\n        CreateOrderParams calldata params\n    ) external payable returns (bytes32);\n\n    function cancelDeposit(bytes32 key) external payable;\n    function cancelWithdrawal(bytes32 key) external payable;\n    function cancelOrder(bytes32 key) external payable;\n    \n    /**\n     * @dev Claims funding fees for the given markets and tokens on behalf of the caller, and sends the\n     * fees to the specified receiver. The length of the `markets` and `tokens` arrays must be the same.\n     * For each market-token pair, the `claimFundingFees()` function in the `MarketUtils` contract is\n     * called to claim the fees for the caller.\n     *\n     * @param markets An array of market addresses\n     * @param tokens An array of token addresses, corresponding to the given markets\n     * @param receiver The address to which the claimed fees should be sent\n     */\n    function claimFundingFees(\n        address[] memory markets,\n        address[] memory tokens,\n        address receiver\n    ) external payable returns (uint256[] memory);\n\n    function claimCollateral(\n        address[] memory markets,\n        address[] memory tokens,\n        uint256[] memory timeKeys,\n        address receiver\n    ) external payable returns (uint256[] memory);\n\n    /**\n     * @dev Claims affiliate rewards for the given markets and tokens on behalf of the caller, and sends\n     * the rewards to the specified receiver. The length of the `markets` and `tokens` arrays must be\n     * the same. For each market-token pair, the `claimAffiliateReward()` function in the `ReferralUtils`\n     * contract is called to claim the rewards for the caller.\n     *\n     * @param markets An array of market addresses\n     * @param tokens An array of token addresses, corresponding to the given markets\n     * @param receiver The address to which the claimed rewards should be sent\n     */\n    function claimAffiliateRewards(\n        address[] memory markets,\n        address[] memory tokens,\n        address receiver\n    ) external payable returns (uint256[] memory);\n\n    function claimUiFees(\n        address[] memory markets,\n        address[] memory tokens,\n        address receiver\n    ) external payable returns (uint256[] memory);\n}"
    },
    "contracts/interfaces/gmx/IMarket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IMarket {\n    struct Props {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}"
    },
    "contracts/interfaces/gmx/IMarketPoolValueInfo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IMarketPoolValueInfo {\n    struct Props {\n        int256 poolValue;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeePoolFactor;\n\n        uint256 impactPoolAmount;\n    }\n}"
    },
    "contracts/interfaces/gmx/IReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"./IDataStore.sol\"; // Import the DataStore contract\nimport \"./IMarket.sol\"; // Import the Market contract\nimport \"./IMarketPoolValueInfo.sol\"; // Import the MarketPoolValueInfo contract\nimport \"../IPrice.sol\"; // Import the Price contract\n\ninterface IReader {\n    function getMarketTokenPrice(\n        IDataStore dataStore,\n        IMarket.Props memory market,\n        IPrice.Props memory indexTokenPrice,\n        IPrice.Props memory longTokenPrice,\n        IPrice.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, IMarketPoolValueInfo.Props memory);\n}"
    },
    "contracts/interfaces/IPrice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPrice {\n    struct Props {\n        uint256 min;\n        uint256 max;\n    }\n}"
    },
    "contracts/interfaces/lifi/ICalldataVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICalldataVerificationFacet {\n\n    /// @notice Extracts the main parameters from the calldata\n    /// @param data The calldata to extract the main parameters from\n    /// @return bridge The bridge extracted from the calldata\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return amount The min amountfrom the calldata\n    /// @return destinationChainId The destination chain id extracted from the calldata\n    /// @return hasSourceSwaps Whether the calldata has source swaps\n    /// @return hasDestinationCall Whether the calldata has a destination call\n    function extractMainParameters(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            string memory bridge,\n            address sendingAssetId,\n            address receiver,\n            uint256 amount,\n            uint256 destinationChainId,\n            bool hasSourceSwaps,\n            bool hasDestinationCall\n        );\n\n    /// @notice Extracts the generic swap parameters from the calldata\n    /// @param data The calldata to extract the generic swap parameters from\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return amount The amount extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return receivingAssetId The receiving asset id extracted from the calldata\n    /// @return receivingAmount The receiving amount extracted from the calldata\n    function extractGenericSwapParameters(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            address sendingAssetId,\n            uint256 amount,\n            address receiver,\n            address receivingAssetId,\n            uint256 receivingAmount\n        );\n}"
    },
    "contracts/interfaces/vaults/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @dev Interface of the Plugin standard.\n */\ninterface IPlugin {\n    enum ActionType {\n        // Action types\n        Stake,\n        Unstake,\n        SwapTokens,\n        ClaimRewards,\n        CancelAction,\n        ClaimUiFees,\n        ClaimAffiliateRewards,\n        ClaimCollateral,\n        ClaimFundingFees\n    }\n\n    function execute(ActionType _actionType, bytes calldata _payload) external payable;\n    \n    function getTotalLiquidity() external view returns (uint256);\n\n    function getPoolNumber() external view returns(uint256);\n\n    function getAllowedTokens(uint8 _poolId) external view returns (address[] memory tokens);\n\n    function getPoolTokenPrice(uint8 _poolId, bool _maximize) external view returns (int256);\n\n    function getPoolTokenInfo(uint8 _poolId) external view returns (address token, uint8 decimal, uint256 balance);\n}\n"
    },
    "contracts/interfaces/vaults/IVaultLocker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n\ninterface IVaultLocker {\n    function getLockerStatus() external view returns(bool);\n}"
    },
    "contracts/vaults/theseus/GmxPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n// Libraries\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"../../interfaces/gmx/IExchangeRouter.sol\";\nimport \"../../interfaces/gmx/IDataStore.sol\";\nimport \"../../interfaces/gmx/IReader.sol\";\nimport \"../../interfaces/gmx/IMarket.sol\";\nimport \"../../interfaces/gmx/ICallbackContract.sol\";\n\nimport \"../TokenPriceConsumer.sol\";\n\ncontract GmxPlugin is Ownable, IPlugin, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /* ========== CONSTANTS ========== */\n    // Constant defining the decimal precision for asset values.\n    uint256 public constant ASSET_DECIMALS = 36;\n\n    // Constant defining the decimal precision for market token prices.\n    uint256 public constant MARKET_TOKEN_PRICE_DECIMALS = 30;\n\n    /* ========== STRUCTS ========== */\n    // Struct defining configuration parameters for the router.\n    struct RouterConfig {\n        address exchangeRouter;   // Address of the exchange router contract.\n        address router;           // Address of the router contract.\n        address depositVault;     // Address of the deposit vault contract.\n        address withdrawVault;    // Address of the withdraw vault contract.\n        address orderVault;       // Address of the order vault contract.\n        address reader;           // Address of the reader contract.\n    }\n\n    // Struct defining configuration parameters for a pool.\n    struct PoolConfig {\n        uint8 poolId;           // Unique identifier for the pool.\n        address indexToken;       // Address of the index token associated with the pool.\n        address longToken;        // Address of the long token associated with the pool.\n        address shortToken;       // Address of the short token associated with the pool.\n        address marketToken;      // Address of the market token associated with the pool.\n    }\n\n    // Struct defining parameters related to Gmx (Governance Mining) functionality.\n    struct GmxParams {\n        address uiFeeReceiver;    // Address to receive UI fees.\n        address callbackContract;  // Address of the callback contract for Gmx interactions.\n        uint256 callbackGasLimit; // Gas limit for Gmx callback functions.\n        uint256 executionFee;     // Execution fee for Gmx interactions.\n        bool shouldUnwrapNativeToken; // Flag indicating whether native tokens should be unwrapped during Gmx interactions.\n        bytes32 pnlFactorType;     // PNL factor type to get the market token price\n    }\n\n    struct PoolValue {\n        uint8 poolId;\n        uint256 poolValue;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n    // Address of the local vault associated with the smart contract.\n    address public localVault;\n\n    // Address of the treasury where funds are managed.\n    address payable public treasury;\n\n    // Configuration parameters for the router, specifying key contracts and components.\n    RouterConfig public routerConfig;\n\n    // Parameters related to Governance Mining (Gmx) functionality.\n    GmxParams public gmxParams;\n\n    // Array storing configuration details for different pools.\n    PoolConfig[] public pools;\n\n    // Mapping to track the existence of pools based on their unique identifiers.\n    mapping(uint8 => bool) public poolExistsMap;\n\n    // Array containing unique tokens associated with the contract.\n    address[] public uniqueTokens;\n\n    // Address of the token price consumer contract used for obtaining token prices.\n    address public tokenPriceConsumer;\n\n    address[] public rewardTokens;\n\n    /* ========== EVENTS ========== */\n    event SetTreasury(address payable treasury);\n    event SetRouterConfig(address _exchangeRouter, address _router, address _depositVault, address _withdrawVault, address _orderVault, address _reader);\n    event SetGmxParams(address _uiFeeReceiver, address _callbackContract, uint256 _callbackGasLimit, uint256 _executionFee, bool _shouldUnwrapNativeToken, bytes32 _pnlFactorType);\n    event SetTokenPriceConsumer(address _tokenPriceConsumer);\n    event SetRewardTokens(address[] _rewardTokens);\n    event PoolAdded(uint8 poolId);\n    event PoolRemoved(uint8 poolId);\n    event Execute(ActionType _actionType, bytes _payload);\n    event TransferAllTokensToVault();\n    event CancelAction(uint8 _actionType, bytes32 _key);\n    event ClaimFromGMX(ActionType _actionType,  uint256[] claimedAmounts);\n    /* ========== MODIFIERS ========== */\n\n    // Modifier allowing only the local vault to execute the function.\n    modifier onlyVault() {\n        require(msg.sender == localVault, \"Invalid caller\");\n        _;\n    }\n\n    // Modifier allowing only the local vault to execute the function.\n    modifier onlyCallback() {\n        require(msg.sender == gmxParams.callbackContract, \"Invalid caller\");\n        _;\n    }\n\n    /* ========== CONFIGURATION ========== */\n\n    // Constructor initializing the GMX contract with the address of the local vault.\n    constructor(address _localVault) Ownable(msg.sender) {\n        // Ensure the provided local vault address is valid.\n        require(_localVault != address(0), \"GMX: Invalid Address\");\n        // Set the localVault address.\n        localVault = _localVault;\n    }\n\n    // Function allowing the owner to set the treasury address.\n    function setTreasury(address payable _treasury) public onlyOwner {\n        // Ensure the provided treasury address is valid.\n        require(_treasury != address(0), \"Vault: Invalid address\");\n        // Set the treasury address.\n        treasury = _treasury;\n        // Emit an event signaling the treasury address update.\n        emit SetTreasury(_treasury);\n    }\n\n\n    // Function allowing the owner to set the router configuration parameters.\n    function setRouterConfig(\n        address _exchangeRouter,\n        address _router,\n        address _depositVault,\n        address _withdrawVault,\n        address _orderVault,\n        address _reader\n    ) external onlyOwner {\n        // Ensure all provided addresses are valid.\n        require(\n            _exchangeRouter != address(0) && \n            _router != address(0) && \n            _depositVault != address(0) && \n            _withdrawVault != address(0) && \n            _orderVault != address(0) && \n            _reader != address(0),\n            \"GMX: Invalid Address\"\n        );\n\n        // Set the router configuration with the provided addresses.\n        routerConfig = RouterConfig({\n            exchangeRouter: _exchangeRouter,\n            router: _router,\n            depositVault: _depositVault,\n            withdrawVault: _withdrawVault,\n            orderVault: _orderVault,\n            reader: _reader\n        });\n\n        emit SetRouterConfig(_exchangeRouter, _router, _depositVault, _withdrawVault, _orderVault, _reader);\n    }\n\n    // Function allowing the owner to set Governance Mining (Gmx) parameters.\n    function setGmxParams(\n        address _uiFeeReceiver,\n        address _callbackContract,\n        uint256 _callbackGasLimit,\n        uint256 _executionFee,\n        bool _shouldUnwrapNativeToken,\n        bytes32 _pnlFactorType\n    ) public onlyOwner {\n        // Set the Gmx parameters with the provided values.\n        gmxParams = GmxParams({\n            uiFeeReceiver: _uiFeeReceiver,\n            callbackContract: _callbackContract,\n            callbackGasLimit: _callbackGasLimit,\n            executionFee: _executionFee,\n            shouldUnwrapNativeToken: _shouldUnwrapNativeToken,\n            pnlFactorType: _pnlFactorType\n        });\n\n        emit SetGmxParams(_uiFeeReceiver, _callbackContract, _callbackGasLimit, _executionFee, _shouldUnwrapNativeToken, _pnlFactorType);\n    }\n\n    // Function allowing the owner to set the token price consumer contract address.\n    function setTokenPriceConsumer(address _tokenPriceConsumer) public onlyOwner {\n        // Ensure the provided token price consumer address is valid.\n        require(_tokenPriceConsumer != address(0), \"GMX: Invalid Address\");\n        \n        // Set the token price consumer contract address.\n        tokenPriceConsumer = _tokenPriceConsumer;\n\n        emit SetTokenPriceConsumer(_tokenPriceConsumer);\n    }\n\n    function setRewardTokens(address[] memory _rewardTokens) public onlyOwner {\n        rewardTokens = _rewardTokens;\n\n        emit SetRewardTokens(_rewardTokens);\n    }\n\n    // Function allowing the owner to add a new pool with specified configuration.\n    function addPool(\n        uint8 _poolId,\n        address _indexToken,\n        address _longToken,\n        address _shortToken,\n        address _marketToken\n    ) external onlyOwner {\n        // Ensure the pool with the given poolId does not already exist.\n        require(_poolId != 0, \"GMX: Invalid Pool Id\");\n        require(!poolExistsMap[_poolId], \"GMX: Pool with this poolId already exists\");\n\n        // Create a new pool configuration and add it to the array.\n        PoolConfig memory newPool = PoolConfig(_poolId, _indexToken, _longToken, _shortToken, _marketToken);\n        pools.push(newPool);\n\n        // Mark the pool as existing.\n        poolExistsMap[_poolId] = true;\n\n        // Add unique tokens to the list if not already present.\n        if (!isTokenAdded(_longToken)) {\n            uniqueTokens.push(_longToken);\n        }\n\n        if (!isTokenAdded(_shortToken)) {\n            uniqueTokens.push(_shortToken);\n        }\n\n        // Emit an event indicating the addition of a new pool.\n        emit PoolAdded(_poolId);\n    }\n\n    function addPools(\n        uint8[] calldata _poolIds,\n        address[] calldata _indexTokens,\n        address[] calldata _longTokens,\n        address[] calldata _shortTokens,\n        address[] calldata _marketTokens\n    ) external onlyOwner {\n        require(\n            _poolIds.length == _indexTokens.length &&\n            _poolIds.length == _longTokens.length &&\n            _poolIds.length == _shortTokens.length &&\n            _poolIds.length == _marketTokens.length,\n            \"GMX: Invalid Array Length\"\n        );\n\n        for (uint256 i = 0; i < _poolIds.length; i++) {\n            this.addPool(_poolIds[i], _indexTokens[i], _longTokens[i], _shortTokens[i], _marketTokens[i]);\n        }\n    }\n\n    // Function allowing the owner to remove an existing pool.\n    function removePool(uint8 _poolId) external onlyOwner {\n        // Ensure the pool with the given poolId exists.\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n\n        // Find the index of the pool in the array.\n        uint256 indexToRemove = getPoolIndexById(_poolId);\n\n        // Swap the pool to remove with the last pool in the array.\n        // This avoids leaving gaps in the array.\n        uint256 lastIndex = pools.length - 1;\n        if (indexToRemove != lastIndex) {\n            pools[indexToRemove] = pools[lastIndex];\n        }\n\n        // Remove the last pool (which now contains the removed pool's data).\n        pools.pop();\n\n        // Mark the pool as no longer existing.\n        delete poolExistsMap[_poolId];\n\n        // Update the list of unique tokens.\n        updateUniqueTokens();\n\n        // Emit an event indicating the removal of an existing pool.\n        emit PoolRemoved(_poolId);\n    }\n\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n    // Function allowing the vault to execute different actions based on the specified action type.\n    function execute(ActionType _actionType, bytes calldata _payload) external payable onlyVault nonReentrant {\n        // Determine the action type and execute the corresponding logic.\n        if (_actionType == ActionType.Stake) {\n            // Execute stake action.\n            stake(_payload);\n        } else if (_actionType == ActionType.Unstake) {\n            // Execute unstake a ction.\n            unstake(_payload);\n        } else if (_actionType == ActionType.SwapTokens) {\n            // Execute token swap action (create order).\n            createOrder(_payload);\n        } else if (_actionType == ActionType.CancelAction) {\n            // Execute cancel action.\n            cancelAction(_payload);\n        } else if (_actionType == ActionType.ClaimRewards) {\n            claimRewards();\n        } else {\n            claimFromGMX(_actionType, _payload);\n        }\n\n        emit Execute(_actionType, _payload);\n    }\n\n    function claimFromGMX(ActionType _actionType, bytes calldata _payload) internal {\n        (address[] memory markets, address[] memory tokens, uint256[] memory timeKeys, uint256 amount) = abi.decode(_payload, (address[], address[], uint256[], uint256));\n        uint256[] memory claimedAmounts = new uint256[](markets.length);\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        if (_actionType == ActionType.ClaimUiFees ) {\n            claimedAmounts = _exchangeRouter.claimUiFees{value: amount}(markets, tokens, localVault);\n            emit ClaimFromGMX(_actionType, claimedAmounts);\n        } else if (_actionType == ActionType.ClaimAffiliateRewards) {\n            claimedAmounts = _exchangeRouter.claimAffiliateRewards{value: amount}(markets, tokens, localVault);\n            emit ClaimFromGMX(_actionType, claimedAmounts);\n        } else if (_actionType == ActionType.ClaimCollateral) {\n            claimedAmounts = _exchangeRouter.claimCollateral{value: amount}(markets, tokens, timeKeys, localVault);\n            emit ClaimFromGMX(_actionType, claimedAmounts);\n        } else if (_actionType == ActionType.ClaimFundingFees) {\n            claimedAmounts = _exchangeRouter.claimFundingFees{value: amount}(markets, tokens, localVault);\n            emit ClaimFromGMX(_actionType, claimedAmounts);\n        }\n    }\n\n    // Transfers all ERC-20 tokens held by this contract to a designated vault.\n    function transferAllTokensToVault() public onlyCallback {\n        // Iterate through all unique tokens stored in the contract\n        for (uint256 i = 0; i < uniqueTokens.length; ++i) {\n            // Get the balance of the current token held by this contract\n            uint256 tokenBalance = IERC20(uniqueTokens[i]).balanceOf(address(this));\n\n            // Check if the token balance is greater than zero\n            if (tokenBalance > 0) {\n                // Safely transfer the entire balance of the current token to the designated vault\n                IERC20(uniqueTokens[i]).safeTransfer(localVault, tokenBalance);\n            }\n        }\n\n        emit TransferAllTokensToVault();\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    // Function to calculate the total liquidity (totalAsset) of the vault, considering balances in unique tokens and pools.\n    function getTotalLiquidity() public view returns (uint256 totalAsset) {\n        // Iterate over uniqueTokens and calculate totalAsset based on token balances.\n        for (uint256 i = 0; i < uniqueTokens.length; ++i) {\n            address tokenAddress = uniqueTokens[i];\n            uint256 tokenBalance = IERC20(tokenAddress).balanceOf(address(this));\n            totalAsset += calculateTokenValueInUsd(tokenAddress, tokenBalance);\n        }\n\n        // Iterate over pools and calculate totalAsset based on market token balances and prices.\n        for (uint256 i = 0; i < pools.length; ++i) {\n            address marketTokenAddress = pools[i].marketToken;\n            uint256 marketTokenBalance = IERC20(marketTokenAddress).balanceOf(address(this));\n            int256 marketTokenPrice = getPoolTokenPrice(pools[i].poolId, true);\n            if (marketTokenPrice <= 0) continue;\n            uint256 amount = marketTokenBalance * uint256(marketTokenPrice);\n\n            // Use IERC20Metadata only once to get decimals.\n            uint256 decimals = IERC20Metadata(marketTokenAddress).decimals() + MARKET_TOKEN_PRICE_DECIMALS;\n\n            uint256 adjustedAmount = convertDecimals(amount, decimals, ASSET_DECIMALS);\n\n            // Accumulate adjustedAmount to totalAsset.\n            totalAsset += adjustedAmount;\n        }\n    }\n\n    // Public view function that retrieves an array of PoolValues representing the values of each pool.\n    // Each PoolValue includes the poolId and the adjusted market value of the pool.\n    // The adjusted market value is calculated based on the balance and price of the market token in each pool.\n    function getPoolValues() public view returns (PoolValue[] memory){\n        // Initialize a dynamic array to store PoolValues for each pool.\n        PoolValue[] memory poolValues = new PoolValue[](pools.length);\n\n        // Iterate through each pool to calculate and store the adjusted market value.\n        for (uint256 i = 0; i < pools.length; ++i) {\n            address marketTokenAddress = pools[i].marketToken;\n            uint256 marketTokenBalance = IERC20(marketTokenAddress).balanceOf(address(this));\n\n            // Get the current price of the market token in the pool.\n            int256 marketTokenPrice = getPoolTokenPrice(pools[i].poolId, true);\n\n            // Calculate the adjusted amount based on the market token balance and price.\n            uint256 adjustedAmount;\n            if (marketTokenPrice > 0) {\n                uint256 amount = marketTokenBalance * uint256(marketTokenPrice);\n\n                // Use IERC20Metadata to get the decimals of the market token.\n                uint256 decimals = IERC20Metadata(marketTokenAddress).decimals() + MARKET_TOKEN_PRICE_DECIMALS;\n\n                // Convert the amount to the desired decimal precision.\n                adjustedAmount = convertDecimals(amount, decimals, ASSET_DECIMALS);\n            }\n\n            // Create a PoolValue struct with poolId and adjusted market value.\n            PoolValue memory data = PoolValue({\n                poolId: pools[i].poolId,\n                poolValue: adjustedAmount\n            });\n\n            // Assign the PoolValue to the array at the correct index.\n            poolValues[i] = data;\n        }\n\n        // Return the array of PoolValues representing the values of each pool.\n        return poolValues;\n    }\n\n    // Function to calculate the USD value of a given token amount based on its price and decimals.\n    function calculateTokenValueInUsd(address _tokenAddress, uint256 _tokenAmount) public view returns (uint256) {\n        uint256 tokenDecimals = TokenPriceConsumer(tokenPriceConsumer).getTokenDecimal(_tokenAddress);\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Get the token price from the TokenPriceConsumer.\n        uint256 tokenPrice = TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        return convertDecimals(_tokenAmount * tokenPrice, tokenDecimals + priceConsumerDecimals, ASSET_DECIMALS);\n    }\n\n\n    // Function to retrieve the total number of pools in the vault.\n    function getPoolNumber() public view returns(uint256) {\n        return pools.length;\n    }\n\n    // Function to retrieve the array of unique tokens stored in the vault.\n    function getUniqueTokens() public view returns (address[] memory) {\n        return uniqueTokens;\n    }\n\n    // Function to retrieve the length of the array of unique tokens.\n    function getUniqueTokenLength() public view returns(uint256) {\n        return uniqueTokens.length;\n    }\n\n    // Function to retrieve the array of pool configurations stored in the vault.\n    function getPools() public view returns(PoolConfig[] memory) {\n        return pools;\n    }\n\n    // Function to retrieve the length of the array of pool configurations.\n    function getPoolLength() public view returns (uint256) {\n        return pools.length;\n    }\n\n    // Function to check if a token is present in the uniqueTokens array.\n    function isTokenAdded(address _token) public view returns(bool) {\n        for(uint256 i; i < uniqueTokens.length; ++i) {\n            if(uniqueTokens[i] == _token) return true;\n        }\n        return false;\n    }\n\n    // Internal function to check if a token exists in the longToken or shortToken of any pool configurations.\n    function tokenExistsInList(address _token) internal view returns (bool) {\n        for (uint256 i = 0; i < pools.length; i++) {\n            if (pools[i].longToken == _token || pools[i].shortToken == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Internal function to get the index of a pool in the array by poolId\n    function getPoolIndexById(uint8 _poolId) public view returns (uint256 poolIndex) {\n        for (uint256 index = 0; index < pools.length; index++) {\n            if (pools[index].poolId == _poolId) {\n                // Pool found, return its index\n                poolIndex = index;\n                return poolIndex;\n            }\n        }\n        // If the pool is not found, revert with an error message\n        revert(\"GMX: Pool not found\");\n    }\n\n    // Updates the 'uniqueTokens' array by removing tokens that no longer exist.\n    function updateUniqueTokens() internal {\n        for (uint256 i = uniqueTokens.length; i > 0; i--) {\n            if (!tokenExistsInList(uniqueTokens[i - 1])) {\n                // Remove the token from uniqueTokens\n                uniqueTokens[i - 1] = uniqueTokens[uniqueTokens.length - 1];\n                uniqueTokens.pop();\n            }\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    // Internal function to stake tokens into a specified pool.\n    // The payload includes the pool ID, an array of two tokens (long and short), and corresponding amounts.\n    // Validates the existence of the pool, array lengths, correct pool tokens, and non-zero token amounts.\n    // Transfers tokens from localVault to the contract and executes buyGMToken function.\n    function stake(bytes calldata _payload) internal {\n        // Decode payload\n        (uint8 _poolId, address[] memory _tokens, uint256[] memory _amounts, bytes memory payload) = abi.decode(_payload, (uint8, address[], uint256[], bytes));\n        (uint256 minGMAmount) = abi.decode(payload, (uint256));\n\n        // Validate pool existence\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n\n        // Validate array lengths\n        require(_tokens.length == 2 && _amounts.length == 2, \"GMX: Array length must be 2\");\n\n        // Get pool index and pool configuration\n        uint256 index = getPoolIndexById(_poolId);\n        PoolConfig memory pool = pools[index];\n\n        // Validate tokens\n        require(pool.longToken == _tokens[0] && pool.shortToken == _tokens[1], \"GMX: Invalid Pool tokens\");\n\n        // Validate token amounts\n        require(_amounts[0] != 0 || _amounts[1] != 0, \"GMX: Invalid token amount\");\n\n        // Transfer tokens from localVault to contract if amounts are positive\n        if (_amounts[0] > 0) {\n            IERC20(pool.longToken).safeTransferFrom(localVault, address(this), _amounts[0]);\n        }\n\n        if (_amounts[1] > 0) {\n            IERC20(pool.shortToken).safeTransferFrom(localVault, address(this), _amounts[1]);\n        }\n\n        // Execute buyGMToken function\n        buyGMToken(_poolId, _amounts[0], _amounts[1], minGMAmount);\n    }\n\n    // Internal function to unstake GM tokens from a specified pool.\n    // The payload includes the pool ID and the market amount to sell.\n    // Decodes the payload and performs the sell operation using sellGMToken function.\n    function unstake(bytes calldata _payload) internal {\n        // Decode payload\n        (uint8 poolId, uint256 marketAmount, uint256 lpAmount, address receiver, bytes memory data) = abi.decode(_payload, (uint8, uint256, uint256, address, bytes));\n        (uint256 minLongTokenAmount, uint256 minShortTokenAmount) = abi.decode(data, (uint256, uint256));\n\n        // Perform sell operation\n        sellGMToken(poolId, marketAmount, lpAmount, minLongTokenAmount, minShortTokenAmount, receiver);\n    }\n\n    // Internal function to create a GM token order using provided order parameters.\n    // The payload includes order parameters in the CreateOrderParams structure.\n    // Decodes the payload and executes createGMOrder function.\n    function createOrder(bytes calldata _payload) internal {\n        // Decode payload\n        IExchangeRouter.CreateOrderParams memory orderParams = abi.decode(_payload, (IExchangeRouter.CreateOrderParams));\n\n        // Execute createGMOrder function\n        createGMOrder(orderParams);\n    }\n\n    // This internal function is responsible for canceling different types of actions based on the provided payload.\n    // It decodes the payload to extract action type and key information, then calls corresponding cancellation functions.\n    // The supported action types are: 0 for canceling deposit, 1 for canceling withdrawal, and 2 for canceling an order.\n    function cancelAction(bytes calldata _payload) internal {\n        (uint8 _actionType, bytes32 _key) = abi.decode(_payload, (uint8, bytes32));\n        if(_actionType == 0) {\n            cancelDeposit(_key);    // Cancels a deposit with the specified key.\n        } else if(_actionType == 1) {\n            cancelWithdrawal(_key); // Cancels a withdrawal with the specified key.\n        } else if(_actionType == 2) {\n            cancelOrder(_key);      // Cancels an order with the specified key.\n        }\n\n        emit CancelAction(_actionType, _key); // Emits an event to log the canceled action type and key.\n    }\n\n    // This internal function is responsible for claiming rewards for each token in the rewardTokens array.\n    // It iterates through the rewardTokens, checks the balance of each token, and transfers the balance to a local vault.\n    // The localVault variable should be set appropriately before calling this function.\n    function claimRewards() internal {\n        for(uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 amount = IERC20(rewardTokens[i]).balanceOf(address(this));\n            if(amount > 0) {\n                // Safely transfers the reward amount to the specified localVault address.\n                IERC20(rewardTokens[i]).safeTransfer(localVault, amount);\n            }\n        }\n    }\n\n\n    /* ========== GMX FUNCTIONS ========== */\n    // Internal function to buy GM tokens in a specified pool.\n    // Handles the approval of token transfers, prepares swap paths, and executes multicall to deposit assets and create GM tokens.\n    function buyGMToken(uint8 _poolId, uint256 _longTokenAmount, uint256 _shortTokenAmount, uint256 _minGmAmount) internal {\n        // Retrieve pool configuration\n        PoolConfig memory pool = pools[getPoolIndexById(_poolId)];\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Prepare swap paths and other variables\n        address longToken = pool.longToken;\n        address shortToken = pool.shortToken;\n        address marketAddress = pool.marketToken;\n        address[] memory longTokenSwapPath;\n        address[] memory shortTokenSwapPath;\n        uint256 executionFee = gmxParams.executionFee;\n\n        // Prepare CreateDepositParams\n        IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams(\n            address(this),                     // receiver\n            gmxParams.callbackContract,        // callbackContract\n            gmxParams.uiFeeReceiver,           // uiFeeReceiver\n            marketAddress,\n            longToken,\n            shortToken,\n            longTokenSwapPath,\n            shortTokenSwapPath,\n            _minGmAmount,                  // minMarketTokens\n            gmxParams.shouldUnwrapNativeToken, // shouldUnwrapNativeToken\n            executionFee,\n            gmxParams.callbackGasLimit         // callbackGasLimit\n        );\n\n        // Approve token transfers if amounts are greater than 0\n        if (_longTokenAmount > 0) {\n            IERC20(longToken).safeIncreaseAllowance(routerConfig.router, _longTokenAmount);\n        }\n\n        if (_shortTokenAmount > 0) {\n            IERC20(shortToken).safeIncreaseAllowance(routerConfig.router, _shortTokenAmount);\n        }\n\n        // Prepare multicall arguments\n        bytes[] memory multicallArgs = new bytes[](4);\n\n        // Encode external contract calls for multicall\n        multicallArgs[0] = abi.encodeWithSignature(\"sendWnt(address,uint256)\", routerConfig.depositVault, executionFee);\n        multicallArgs[1] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", longToken, routerConfig.depositVault, _longTokenAmount);\n        multicallArgs[2] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", shortToken, routerConfig.depositVault, _shortTokenAmount);\n        multicallArgs[3] = abi.encodeWithSignature(\"createDeposit((address,address,address,address,address,address,address[],address[],uint256,bool,uint256,uint256))\", params);\n\n        // Execute multicall with optional value (executionFee)\n        bytes[] memory results = _exchangeRouter.multicall{value: executionFee}(multicallArgs);\n        ICallbackContract(gmxParams.callbackContract).addKey(bytes32(results[3]), ICallbackContract.State.Deposit);\n    }\n\n    // Internal function to sell GM tokens in a specified pool.\n    function sellGMToken(uint8 _poolId, uint256 marketAmount, uint256 lpAmount, uint256 _minLongTokenAmount, uint256 _minShortTokenAmount, address receiver) internal {\n        // Retrieve pool configuration\n        PoolConfig memory pool = pools[getPoolIndexById(_poolId)];\n\n        // Cast exchangeRouter to IExchangeRouter\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Define swap paths\n        address[] memory longTokenSwapPath;\n        address[] memory shortTokenSwapPath;\n\n        // Check if the contract has sufficient market token balance\n        uint256 balance = IERC20(pool.marketToken).balanceOf(address(this));\n        require(balance >= marketAmount && marketAmount > 0, \"GMX: Insufficient market token balance\");\n\n        // Create parameters for the external contract call\n        IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams(\n            receiver,                          // receiver\n            gmxParams.callbackContract,        // callbackContract\n            gmxParams.uiFeeReceiver,           // uiFeeReceiver\n            pool.marketToken,                  // market\n            longTokenSwapPath,                 // longTokenSwapPath\n            shortTokenSwapPath,                // shortTokenSwapPath\n            _minLongTokenAmount,               // minLongTokens\n            _minShortTokenAmount,              // minShortTokens\n            gmxParams.shouldUnwrapNativeToken, // shouldUnwrapNativeToken\n            gmxParams.executionFee,            // execution fee\n            gmxParams.callbackGasLimit         // callbackGasLimit\n        );\n\n        // Approve market token transfer\n        IERC20(pool.marketToken).safeIncreaseAllowance(routerConfig.router, marketAmount);\n\n        // Initialize an array to store multicall arguments\n        bytes[] memory multicallArgs = new bytes[](3);\n\n        // Encode external contract calls for multicall\n        multicallArgs[0] = abi.encodeWithSignature(\"sendWnt(address,uint256)\", routerConfig.withdrawVault, gmxParams.executionFee);\n        multicallArgs[1] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", pool.marketToken, routerConfig.withdrawVault, marketAmount);\n        multicallArgs[2] = abi.encodeWithSignature(\"createWithdrawal((address,address,address,address,address[],address[],uint256,uint256,bool,uint256,uint256))\", params);\n\n        // Execute multicall with optional value (executionFee)\n        bytes[] memory results = _exchangeRouter.multicall{value: gmxParams.executionFee}(multicallArgs);\n    \n        ICallbackContract(gmxParams.callbackContract).addKey(bytes32(results[2]), ICallbackContract.State.Withdrawal);\n        ICallbackContract(gmxParams.callbackContract).addWithdrawalData(bytes32(results[2]), lpAmount, receiver);\n    }\n\n    // Create Gmx order with the gmx order params\n    function createGMOrder(IExchangeRouter.CreateOrderParams memory _params) internal {\n        require(_params.addresses.receiver == localVault, \"Invalid receiver\");\n\n        _params.addresses.cancellationReceiver = localVault;\n        _params.addresses.callbackContract = gmxParams.callbackContract;\n        _params.addresses.uiFeeReceiver = gmxParams.uiFeeReceiver;\n        _params.numbers.callbackGasLimit = gmxParams.callbackGasLimit;\n        \n        // Cast exchangeRouter to IExchangeRouter\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Extract values from _params to improve readability\n        address initialCollateralToken = _params.addresses.initialCollateralToken;\n\n        uint256 initialCollateralDeltaAmount = _params.numbers.initialCollateralDeltaAmount;\n\n        _params.numbers.executionFee= gmxParams.executionFee;\n        _params.numbers.callbackGasLimit = gmxParams.callbackGasLimit;\n\n        if (\n            _params.orderType == IExchangeRouter.OrderType.MarketSwap ||\n            _params.orderType == IExchangeRouter.OrderType.LimitSwap ||\n            _params.orderType == IExchangeRouter.OrderType.MarketIncrease ||\n            _params.orderType == IExchangeRouter.OrderType.LimitIncrease\n        ) {\n\n            // Transfer initialCollateralToken from localVault to contract\n            IERC20(initialCollateralToken).safeTransferFrom(localVault, address(this), initialCollateralDeltaAmount);\n    \n            // Approve initialCollateralToken transfer\n            IERC20(initialCollateralToken).safeIncreaseAllowance(routerConfig.router, initialCollateralDeltaAmount);\n    \n            // Transfer initialCollateralToken to orderVault\n            _exchangeRouter.sendTokens(initialCollateralToken, routerConfig.orderVault, initialCollateralDeltaAmount);\n        }\n\n        // Send execution fee to orderVault\n        _exchangeRouter.sendWnt{value: gmxParams.executionFee}(routerConfig.orderVault, gmxParams.executionFee);\n\n        // Create the order using the external exchange router\n        bytes32 orderKey = _exchangeRouter.createOrder(_params);\n        \n        ICallbackContract(gmxParams.callbackContract).addKey(orderKey, ICallbackContract.State.Order);\n    }\n\n    // Cancels a deposit operation identified by the specified key using the configured exchange router.\n    function cancelDeposit(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the deposit with the specified key\n        _exchangeRouter.cancelDeposit(key);\n    }\n\n    // Cancels a withdrawal operation identified by the specified key using the configured exchange router.\n    function cancelWithdrawal(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the withdrawal with the specified key\n        _exchangeRouter.cancelWithdrawal(key);\n    }\n\n    // Cancels an order identified by the specified key using the configured exchange router.\n    function cancelOrder(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the order with the specified key\n        _exchangeRouter.cancelOrder(key);\n    }\n\n    // Get the pool token price with the poolId\n    function getPoolTokenPrice(uint8 _poolId, bool _maximize) public view returns (int256) {\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n        \n        // Retrieve pool configuration\n        PoolConfig memory _pool = pools[getPoolIndexById(_poolId)];\n\n        // Cast exchangeRouter to IExchangeRouter for interacting with the external contract\n        IExchangeRouter exchangeRouterInstance = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Retrieve dataStore from the exchangeRouter\n        IDataStore dataStore = exchangeRouterInstance.dataStore();\n\n        // Define market properties for the external contract call\n        IMarket.Props memory marketProps = IMarket.Props(\n            _pool.marketToken,\n            _pool.indexToken,\n            _pool.longToken,\n            _pool.shortToken\n        );\n\n        // Fetch token prices for indexToken, longToken, and shortToken\n        IPrice.Props memory indexTokenPrice = getTokenPriceInfo(_pool.indexToken);\n        IPrice.Props memory longTokenPrice = getTokenPriceInfo(_pool.longToken);\n        IPrice.Props memory shortTokenPrice = getTokenPriceInfo(_pool.shortToken);\n\n        // Define additional parameters for the external contract call\n        bytes32 pnlFactorType = gmxParams.pnlFactorType;\n        bool maximize = _maximize;\n\n        // Call the external contract to get the market token price\n        (int256 marketTokenPrice, ) = IReader(routerConfig.reader).getMarketTokenPrice(\n            dataStore,\n            marketProps,\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        // Return the calculated market token price\n        return marketTokenPrice;\n    }\n\n    // Retrieves token price information, adjusting for decimals.\n    function getTokenPriceInfo(address token) public view returns (IPrice.Props memory) {\n        if(token == address(0)) return IPrice.Props(0, 0);\n\n        // Create an instance of TokenPriceConsumer for fetching token prices\n        TokenPriceConsumer priceConsumer = TokenPriceConsumer(tokenPriceConsumer);\n\n        uint256 tokenDecimal = priceConsumer.getTokenDecimal(token);\n        \n        IPrice.Props memory tokenPrice = IPrice.Props(\n            convertDecimals(priceConsumer.getTokenPrice(token), priceConsumer.decimals(token), MARKET_TOKEN_PRICE_DECIMALS - tokenDecimal),\n            convertDecimals(priceConsumer.getTokenPrice(token), priceConsumer.decimals(token), MARKET_TOKEN_PRICE_DECIMALS - tokenDecimal)\n        );\n        return tokenPrice;\n    }\n\n    // Retrieves the long and short tokens allowed in a pool.\n    function getAllowedTokens(uint8 _poolId) public view returns (address[] memory) {\n        // Create an empty array to return if the pool does not exist\n        address[] memory emptyArray;\n\n        // Check if the pool with the given ID exists\n        if (!poolExistsMap[_poolId]) {\n            // Return an empty array if the pool does not exist\n            return emptyArray;\n        }\n\n        // Create an array to store the addresses of allowed tokens (long and short)\n        address[] memory tokens = new address[](2);\n\n        // Retrieve the index of the pool in the pools array\n        uint256 index = getPoolIndexById(_poolId);\n\n        // Retrieve the pool configuration using the index\n        PoolConfig memory pool = pools[index];\n\n        // Assign the long and short token addresses to the array\n        tokens[0] = pool.longToken;\n        tokens[1] = pool.shortToken;\n\n        // Return the array containing the addresses of allowed tokens\n        return tokens;\n    }   \n\n    // Retrieves information about a pool identified by its ID.\n    function getPoolTokenInfo(uint8 _poolId) public view returns (address, uint8, uint256) {\n        // Check if the pool with the given ID exists\n        if (!poolExistsMap[_poolId]) {\n            // Return default values if the pool does not exist\n            return (address(0), 0, 0);\n        }\n\n        // Retrieve the index of the pool in the pools array\n        uint256 index = getPoolIndexById(_poolId);\n\n        // Retrieve the pool configuration using the index\n        PoolConfig memory pool = pools[index];\n\n        // Get the decimals of the market token associated with the pool\n        uint8 decimals = IERC20Metadata(pool.marketToken).decimals();\n\n        // Get the balance of the market token held by this contract\n        uint256 balance = IERC20(pool.marketToken).balanceOf(address(this));\n\n        // Return the market token address, decimals, and balance in a tuple\n        return (pool.marketToken, decimals, balance);\n    }\n\n    // Converts an amount from one decimal precision to another.\n    function convertDecimals(uint256 _amount, uint256 _from, uint256 _to) public pure returns (uint256) {\n        if(_from >= _to) return _amount / 10 ** (_from - _to);\n        else return _amount * 10 ** (_to - _from);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function withdrawFee(uint256 _amount) public onlyOwner {\n        // get the amount of Ether stored in this contract\n        uint amount = address(this).balance;\n        require(amount >= _amount, \"Vault: Invalid withdraw amount.\");\n                                                  \n        require(treasury != address(0), \"Vault: Invalid treasury\");\n        (bool success, ) = treasury.call{value: _amount}(\"\");\n        require(success, \"Vault: Failed to send Ether\");\n    }\n\n    receive() external payable {}\n    fallback() external payable {}\n}"
    },
    "contracts/vaults/theseus/MultiCallVaultMaster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/gmx/IExchangeRouter.sol\";\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"./Vault.sol\";\n\ncontract MultiCallVaultMaster is Ownable {\n    using SafeERC20 for IERC20;\n\n    struct LifiCallData {\n        address srcToken;\n        uint256 amount;\n        uint256 value;\n        bool bridge;\n        bytes data;\n    }\n\n    enum MultiCallAction {\n        Stake,\n        Unstake,\n        SwapLifi,\n        SwapGMX,\n        /// @notice For the swap part of this action only sawp via lifi is possible, since sawp via gmx is not atomic\n        SwapAndStake,\n        Cancel\n    }\n\n    address payable public vault;\n\n    address public admin;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"MultiCallVaultMaster: caller is not the admin\");\n        _;\n    }\n\n    constructor(address _admin) Ownable(msg.sender)\n    {\n        admin = _admin;\n    }\n\n    function setVault(address payable _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    function setAdmin(address _admin) external onlyOwner {\n        admin = _admin;\n    }\n\n    function executeMultiCall(uint8 _pluginId, MultiCallAction _action, bytes[] memory _payloads, LifiCallData[] memory _lifiCallData) onlyAdmin external {\n       if(_action == MultiCallAction.Stake) {\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                Vault(vault).execute(_pluginId, IPlugin.ActionType.Stake, _payloads[i]);\n            }\n       } else if(_action == MultiCallAction.Unstake) {\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                Vault(vault).execute(_pluginId, IPlugin.ActionType.Unstake, _payloads[i]);\n            }\n       } else if(_action == MultiCallAction.SwapGMX) {\n            address[] memory _tokens = new address[](_payloads.length);\n            uint256[] memory _amounts = new uint256[](_payloads.length);\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                IExchangeRouter.CreateOrderParams memory orderParams = abi.decode(_payloads[i], (IExchangeRouter.CreateOrderParams));\n                _tokens[i] = orderParams.addresses.initialCollateralToken;\n                _amounts[i] = orderParams.numbers.initialCollateralDeltaAmount;\n            }\n            Vault(vault).approveTokens(_pluginId, _tokens, _amounts);\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                Vault(vault).execute(_pluginId, IPlugin.ActionType.SwapTokens, _payloads[i]);\n            }\n       } else if(_action == MultiCallAction.Cancel) {\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                Vault(vault).execute(_pluginId, IPlugin.ActionType.CancelAction, _payloads[i]);\n            }\n       } else if(_action == MultiCallAction.SwapLifi) {         \n            for(uint256 i = 0; i < _lifiCallData.length; i++) {\n                address _srcToken = _lifiCallData[i].srcToken;\n                uint256 _amount = _lifiCallData[i].amount;\n                uint256 _value = _lifiCallData[i].value;\n                bool _bridge = _lifiCallData[i].bridge;\n                bytes memory _data = _lifiCallData[i].data;\n                Vault(vault).bridgeViaLifi(_srcToken, _amount, _value, _bridge, _data);\n            }\n       } else if(_action == MultiCallAction.SwapAndStake) {     \n            for(uint256 i = 0; i < _lifiCallData.length; i++) {\n                address _srcToken = _lifiCallData[i].srcToken;\n                uint256 _amount = _lifiCallData[i].amount;\n                uint256 _value = _lifiCallData[i].value;\n                bool _bridge = _lifiCallData[i].bridge;\n                bytes memory _data = _lifiCallData[i].data;\n                Vault(vault).bridgeViaLifi(_srcToken, _amount, _value, _bridge, _data);\n            }\n\n            for(uint256 i = 0; i < _payloads.length; i++) {\n                Vault(vault).execute(_pluginId, IPlugin.ActionType.Stake, _payloads[i]);\n            }\n       }\n    }  \n\n    fallback() external payable onlyAdmin {\n        assembly {\n            let _vault := sload(vault.slot)\n            calldatacopy(0, 0, calldatasize())\n            let result := call(gas(), _vault, callvalue(), 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n                case 0 {revert(0, returndatasize())}\n                default {return (0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {} \n\n    function withdrawStuckEth(address toAddr) external onlyOwner {\n        (bool success, ) = toAddr.call{\n            value: address(this).balance\n        } (\"\");\n        require(success);\n    }\n\n    function withdrawStuckToken(address token,address _to) external onlyOwner {\n        require(_to != address(0), \"Zero address\");\n        uint256 _contractTokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(_to, _contractTokenBalance);\n    }\n}"
    },
    "contracts/vaults/theseus/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n// Libraries\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\n\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"../../interfaces/vaults/IVaultLocker.sol\";\nimport \"../../interfaces/lifi/ICalldataVerificationFacet.sol\";\nimport \"../TokenPriceConsumer.sol\";\n\n\ncontract Vault is Ownable, ERC20, ERC20Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constant representing the number of decimals for the MOZAIC token.\n    uint256 public constant MOZAIC_DECIMALS = 6;\n\n    // Constant representing the number of decimals for the ASSET.\n    uint256 public constant ASSET_DECIMALS = 36;\n\n    // A constant representing the denominator for basis points (BP). Used for percentage calculations.\n    uint256 public constant BP_DENOMINATOR = 1e4;\n\n    // A constant representing the maximum fee percentage allowed (1000 basis points or 10% in this case).\n    uint256 public constant MAX_FEE = 1e3;\n\n    // The Address of lifi contract\n    address public constant LIFI_CONTRACT = 0x1231DEB6f5749EF6cE6943a275A1D3E7486F4EaE;\n\n    // Struct defining the properties of a Plugin.\n    struct Plugin {\n        address pluginAddress;  // Address of the plugin contract.\n        uint8 pluginId;       // Unique identifier for the plugin.\n    }\n    \n    /* ========== STATE VARIABLES ========== */\n    // Stores the address of the multicall master Contract contract. \n    address public masterContract;\n\n    // Stores the address of the contract admin.\n    address public admin;\n\n    // Stores the address of the treasury, which is payable for receiving funds.\n    address payable public treasury;\n\n    // Stores the address of the token price consumer contract.\n    address public tokenPriceConsumer;\n\n    // Maps plugin IDs to their respective index.\n    mapping(uint8 => uint256) public pluginIdToIndex;\n\n    // An array to store instances of the Plugin struct.\n    Plugin[] public plugins;\n\n    // Maps token addresses to boolean values indicating whether the token is accepted.\n    mapping(address => bool) public acceptedTokenMap;\n\n    // An array of accepted token addresses.\n    address[] public acceptedTokens;\n\n    // Maps token addresses to boolean values indicating whether deposits are allowed for the token.\n    mapping(address => bool) public depositAllowedTokenMap;\n\n    // An array of token addresses for which deposits are allowed.\n    address[] public depositAllowedTokens;\n\n    // Stores the ID of the currently selected plugin.\n    uint8 public selectedPluginId;\n\n    // Stores the ID of the currently selected pool.\n    uint8 public selectedPoolId;\n\n    // An array of addresses representing users who can lock assets in the vault.\n    address[] public vaultLockers;\n\n    // An array of addresses representing managers who have control over the vault.\n    address[] public vaultManagers;\n\n    // A rate used to convert LP (Liquidity Provider) tokens to a standard decimal format (18 decimals in this case).\n    uint256 public lpRate = 1e18;\n\n    // The percentage of fees collected by the protocol for each transaction.\n    uint256 public protocolFeePercentage;\n\n    // The total protocol fee held in the vault.\n    uint256 public protocolFeeInVault;\n\n    // The minimum execution fee required when depositing funds into the vault.\n    uint256 public depositMinExecFee;\n\n    // The minimum execution fee required when withdrawing funds from the vault.\n    uint256 public withdrawMinExecFee;\n\n    struct lifiWhiteListReceiver {\n        uint256 chainId;\n        bool isWhiteListed;\n    }\n    // The list of addresses that can receive funds from the vault via lifi bridge.\n    mapping(address => lifiWhiteListReceiver) public lifiReceiverWhiteList;\n\n\n    /* ========== EVENTS ========== */\n    event AddPlugin(uint8 _pluginId, address _pluginAddress);\n    event RemovePlugin(uint8 _pluginId);\n    event Execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes _payload);\n    event MasterUpdated(address _oldMaster, address _newMaster);\n    event AdminUpdated(address _oldAdmin, address _newAdmin);\n    event TokenPriceConsumerUpdated(address _oldTokenPriceConsumer, address _newTokenPriceConsumer);\n    event SetTreasury(address payable treasury);\n    event SetProtocolFeePercentage(uint256 _protocolFeePercentage);\n    event SetExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee);\n    event SetVaultLockers(address[] _vaultLockers);\n    event SetVaultManagers(address[] _vaultManagers);\n    event UpdateLiquidityProviderRate(uint256 _previousRate, uint256 _lpRate);\n    event AddAcceptedToken(address _token);\n    event RemoveAcceptedToken(address _token);\n    event AddDepositAllowedToken(address _token);\n    event RemoveDepositAllowedToken(address _token);\n    event AddDepositRequest(address _token, uint256 _amount);\n    event AddWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver);\n    event SelectPluginAndPool(uint8 _pluginId, uint8 _poolId);\n    event ApproveTokens(uint8 _pluginId, address[] _tokens, uint256[] _amounts);\n    event WithdrawProtocolFee(address _token, uint256 _amount);\n    event StakeToSelectedPool(uint8 _selectedPluginId, uint8 _selectedPoolId, address _token, uint256 _tokenAmount);\n    event SetLifiReceiverWhiteList(address _receiver, uint256 _chaindId, bool _status);\n\n\n    /* ========== MODIFIERS ========== */\n    // Modifier allowing only the masterContract contract to execute the function.\n    modifier onlyMaster() {\n        require(msg.sender == masterContract, \"Vault: caller must be masterContract\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Vault: caller must be admin\");\n        _;\n    }\n\n\n    // Modifier allowing only the vault lockers to execute the function.\n    modifier onlyVaultLockers() {\n        bool isVaultLocker = false;\n        for(uint256 i  = 0; i < vaultLockers.length; i++) {\n            if(vaultLockers[i] == msg.sender) {\n                isVaultLocker = true;\n                break;\n            }\n        }\n        require(isVaultLocker, \"Vault: Invalid vault locker\");\n        _;\n    }\n\n    // Modifier allowing only the vault managers to execute the function.\n    modifier onlyVaultManagers() {\n        bool isVaultManager = false;\n        for(uint256 i  = 0; i < vaultManagers.length; i++) {\n            if(vaultManagers[i] == msg.sender) {\n                isVaultManager = true;\n                break;\n            }\n        }\n        require(isVaultManager, \"Vault: Invalid vault manager\");\n        _;\n    }\n\n    /* ========== CONFIGURATION ========== */\n    // Constructor for the Mozaic Theseus LPToken contract, inheriting from ERC20.\n    constructor(address _master,address _admin, address _tokenPriceConsumer, address payable _treasury) ERC20(\"Mozaic Theseus LP\", \"MOZ-THE-LP\") Ownable(msg.sender){\n        require(_master != address(0), \"Vault: Invalid Address\");\n        require(_admin != address(0), \"Vault: Invalid Address\");\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n        require(_treasury != address(0), \"Vault: Invalid Address\");\n\n        masterContract = _master;\n        tokenPriceConsumer = _tokenPriceConsumer;\n        treasury = _treasury;\n        admin = _admin;\n\n        lifiReceiverWhiteList[address(this)] = lifiWhiteListReceiver(block.chainid, true);\n\n        lifiReceiverWhiteList[treasury] = lifiWhiteListReceiver(block.chainid, true);\n    }\n\n    // Allows the owner to set a new masterContract address for the Vault.\n    function setMaster(address _newMaster) external onlyOwner {\n        // Ensure that the new masterContract address is valid.\n        require(_newMaster != address(0), \"Vault: Invalid Address\");\n\n        // Store the current masterContract address before updating.\n        address _oldMaster = masterContract;\n\n        // Update the masterContract address to the new value.\n        masterContract = _newMaster;\n\n        // Emit an event to log the masterContract address update.\n        emit MasterUpdated(_oldMaster, _newMaster);\n    }\n\n    // Allows the owner to set a new admin address for the Vault.\n    function setAdmin(address _newAdmin) external onlyOwner {\n        // Ensure that the new admin address is valid.\n        require(_newAdmin != address(0), \"Vault: Invalid Address\");\n\n        // Store the current admin address before updating.\n        address _oldAdmin = admin;\n\n        // Update the admin address to the new value.\n        admin = _newAdmin;\n\n        // Emit an event to log the admin address update.\n        emit MasterUpdated(_oldAdmin, _newAdmin);\n    }\n\n    // Allows the owner to set the address of the token price consumer contract.\n    function setTokenPriceConsumer(address _tokenPriceConsumer) public onlyOwner {\n        // Ensure that the new token price consumer address is valid.\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n\n        // Store the current token price consumer address before updating.\n        address _oldTokenPriceConsumer = tokenPriceConsumer;\n\n        // Update the token price consumer address to the new value.\n        tokenPriceConsumer = _tokenPriceConsumer;\n\n        // Emit an event to log the token price consumer address update.\n        emit TokenPriceConsumerUpdated(_oldTokenPriceConsumer, _tokenPriceConsumer);\n    }\n\n    // Allows the owner to set the address of the treasury.\n    function setTreasury(address payable _treasury) public onlyOwner {\n        // Ensure that the new treasury address is valid.\n        require(_treasury != address(0), \"Vault: Invalid address\");\n\n        // Update the treasury address to the new value.\n        treasury = _treasury;\n\n        // Emit an event to log the treasury address update.\n        emit SetTreasury(_treasury);\n    }\n\n    // Allows the owner to whitelist/remove from whitelist addresses that can receive funds from the vault via lifi bridge.\n    function setLifiReceiverWhiteList(address _receiver,uint256 _chaindId, bool _status) public onlyOwner {\n        lifiReceiverWhiteList[_receiver] = lifiWhiteListReceiver(_chaindId, _status);\n        emit SetLifiReceiverWhiteList(_receiver, _chaindId, _status);\n    }\n\n    // Allows the masterContract contract to select a plugin and pool.\n    function selectPluginAndPool(uint8 _pluginId, uint8 _poolId) onlyAdmin public {\n        // Set the selectedPluginId and selectedPoolId to the provided values.\n        selectedPluginId = _pluginId;\n        selectedPoolId = _poolId;\n        emit SelectPluginAndPool(_pluginId, _poolId);\n    }\n\n    // Sets the execution fees for deposit and withdrawal transactions.\n    function setExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee) public onlyAdmin {\n        // Set the deposit minimum execution fee\n        depositMinExecFee = _depositMinExecFee;\n\n        // Set the withdrawal minimum execution fee\n        withdrawMinExecFee = _withdrawMinExecFee;\n\n        // Emit an event to log the changes in execution fees\n        emit SetExecutionFee(_depositMinExecFee, _withdrawMinExecFee);\n    }\n\n\n    // Allows the owner to add a new accepted token.\n    function addAcceptedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == false) {\n            // Set the token as accepted, add it to the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = true;\n            acceptedTokens.push(_token);\n            emit AddAcceptedToken(_token);\n        } else {\n            // Revert if the token already exists in the accepted tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    function addAcceptedTokens(address[] calldata _tokens) external onlyOwner {\n        for(uint256 i = 0; i < _tokens.length; i++) {\n            this.addAcceptedToken(_tokens[i]);\n        }\n    }\n\n    // Allows the owner to remove an accepted token.\n    function removeAcceptedToken(address _token) external onlyOwner {\n        // Check if the token exists in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == true) {\n            // Set the token as not accepted, remove it from the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = false;\n            for (uint256 i = 0; i < acceptedTokens.length; ++i) {\n                if (acceptedTokens[i] == _token) {\n                    acceptedTokens[i] = acceptedTokens[acceptedTokens.length - 1];\n                    acceptedTokens.pop();\n                    emit RemoveAcceptedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the accepted tokens.\n        revert(\"Vault: Non-accepted token.\");\n    }\n\n    // Allows the owner to add a new deposit allowed token.\n    function addDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == false) {\n            // Set the token as allowed for deposit, add it to the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = true;\n            depositAllowedTokens.push(_token);\n            emit AddDepositAllowedToken(_token);\n        } else {\n            // Revert if the token already exists in the deposit allowed tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    function addDepositAllowedTokens(address[] calldata _tokens) external onlyOwner {\n        for(uint256 i = 0; i < _tokens.length; i++) {\n            this.addDepositAllowedToken(_tokens[i]);\n        }\n    }\n\n    // Allows the owner to remove a deposit allowed token.\n    function removeDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token exists in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == true) {\n            // Set the token as not allowed for deposit, remove it from the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = false;\n            for (uint256 i = 0; i < depositAllowedTokens.length; ++i) {\n                if (depositAllowedTokens[i] == _token) {\n                    depositAllowedTokens[i] = depositAllowedTokens[depositAllowedTokens.length - 1];\n                    depositAllowedTokens.pop();\n                    emit RemoveDepositAllowedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the deposit allowed tokens.\n        revert(\"Vault: Non-deposit allowed token.\");\n    }\n\n    // Allows the owner to add a new plugin to the vault.\n    function addPlugin(uint8 _pluginId, address _pluginAddress) external onlyOwner {\n        // Ensure that the pluginId is not zero and does not already exist.\n        require(_pluginId != 0, \"Vault: PluginId cannot be zero\");\n        require(pluginIdToIndex[_pluginId] == 0, \"Plugin with this ID already exists\");\n\n        // Create a new Plugin instance and add it to the plugins array.\n        plugins.push(Plugin(_pluginAddress, _pluginId));\n        \n        // Update the mapping with the index of the added plugin.\n        pluginIdToIndex[_pluginId] = plugins.length;\n\n        // Emit an event to log the addition of a new plugin.\n        emit AddPlugin(_pluginId, _pluginAddress);\n    }\n\n    // Allows the owner to remove a plugin from the vault.\n    function removePlugin(uint8 _pluginId) external onlyOwner {\n        // Ensure that the pluginId exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Get the index of the plugin in the array.\n        uint256 pluginIndex = pluginIdToIndex[_pluginId] - 1;\n        \n        // Delete the mapping entry for the removed plugin.\n        delete pluginIdToIndex[_pluginId];\n\n        if (pluginIndex != plugins.length - 1) {\n            // If the removed plugin is not the last one, replace it with the last plugin in the array.\n            Plugin memory lastPlugin = plugins[plugins.length - 1];\n            plugins[pluginIndex] = lastPlugin;\n            pluginIdToIndex[lastPlugin.pluginId] = pluginIndex + 1;\n        }\n\n        // Remove the last element from the array.\n        plugins.pop();\n\n        // Emit an event to log the removal of a plugin.\n        emit RemovePlugin(_pluginId);\n    }\n\n    // Function to set the protocol fee percentage. Only callable by the owner of the contract.\n    function setProtocolFeePercentage(uint256 _protocolFeePercentage) external onlyOwner {\n        // Ensure that the provided protocol fee percentage does not exceed the maximum allowed fee.\n        require(_protocolFeePercentage <= MAX_FEE, \"Vault: protocol fee exceeds the max fee\");\n        \n        // Update the protocol fee percentage.\n        protocolFeePercentage = _protocolFeePercentage;\n\n        // Emit an event to log the change in protocol fee percentage.\n        emit SetProtocolFeePercentage(_protocolFeePercentage);\n    }\n\n    // Function to set the addresses of users who can lock assets in the vault. Only callable by the owner.\n    function setVaultLockers(address[] memory _vaultLockers) external onlyOwner {\n        // Update the array of vault lockers with the provided addresses.\n        vaultLockers = _vaultLockers;\n\n        // Emit an event to log the update of vault lockers with the provided addresses.\n        emit SetVaultLockers(_vaultLockers);\n    }\n\n    // Function to set the addresses of managers who have control over the vault. Only callable by the owner.\n    function setVaultManagers(address[] memory _vaultManagers) external onlyOwner {\n        // Update the array of vault managers with the provided addresses.\n        vaultManagers = _vaultManagers;\n\n        // Emit an event to log the update of vault managers with the provided addresses.\n        emit SetVaultManagers(_vaultManagers);\n\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n    \n    // Allows users to initiate a deposit request by converting tokens to LP tokens and staking them into the selected pool.\n    function addDepositRequest(address _token, uint256 _tokenAmount, address _receiver, bytes memory _payload) external payable nonReentrant whenNotPaused {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        require(msg.value >= depositMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure the deposited token is allowed for deposit in the vault.\n        require(isDepositAllowedToken(_token), \"Vault: Invalid token\");\n        \n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Ensure a valid and positive token amount is provided.\n        require(_tokenAmount > 0, \"Vault: Invalid token amount\");\n\n        // Calculate the USD value of the deposited tokens.\n        uint256 amountUsd = calculateTokenValueInUsd(_token, _tokenAmount);\n\n        require(amountUsd >= 10 ** (ASSET_DECIMALS - 2), \"Invalid token amount\");\n\n        // Convert the USD value to the corresponding LP token amount.\n        uint256 lpAmountToMint = convertAssetToLP(amountUsd);\n\n        // Ensure that there is a sufficient LP amount to mint.\n        require(lpAmountToMint > 0, \"Vault: Insufficient amount\");\n\n        // Transfer the deposited tokens from the user to the vault.\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _tokenAmount);\n\n        // Mint the calculated LP tokens and send them to the user.\n        _mint(_receiver, lpAmountToMint);\n\n        // Emit an event to log the deposit request.\n        emit AddDepositRequest(_token, _tokenAmount);\n\n        // Stake the minted LP tokens to the selected pool.\n        stakeToSelectedPool(_token, _tokenAmount, _payload);\n    }\n\n\n    // Internal function to stake a specified token amount to the selected pool using the configured plugin.\n    function stakeToSelectedPool(address _token, uint256 _tokenAmount, bytes memory _payload) internal {\n        // Retrieve the list of allowed tokens for the selected plugin and pool.\n        address[] memory allowedTokens = getTokensByPluginAndPoolId(selectedPluginId, selectedPoolId);\n\n        // Iterate through the allowed tokens to find the matching token.\n        for (uint256 i = 0; i < allowedTokens.length; i++) {\n            if (allowedTokens[i] == _token) {\n                // Create an array to represent token amounts, with the target token's amount set accordingly.\n                uint256[] memory _amounts = new uint256[](allowedTokens.length);\n                _amounts[i] = _tokenAmount;\n\n                // Encode the payload for the 'Stake' action using the selected plugin and pool.\n                bytes memory payload = abi.encode(uint8(selectedPoolId), allowedTokens, _amounts, _payload);\n\n                // Ensure that the specified plugin exists.\n                require(pluginIdToIndex[selectedPluginId] != 0, \"Plugin with this ID does not exist\");\n\n                // Retrieve the plugin address based on the provided plugin ID.\n                address plugin = plugins[pluginIdToIndex[selectedPluginId] - 1].pluginAddress;\n\n                // Increase the allowance for the plugin to spend the specified token amount.\n                IERC20(allowedTokens[i]).safeIncreaseAllowance(plugin, _tokenAmount);\n\n                // Execute the specified action on the plugin with the provided payload.\n                IPlugin(plugin).execute(IPlugin.ActionType.Stake, payload);\n                \n                emit StakeToSelectedPool(selectedPluginId, selectedPoolId, _token, _tokenAmount);\n                // Exit the function after successfully staking the token.\n                return;\n            }\n        }     \n        revert(\"Vault: deposit token not in allowedTokens\");\n    }\n\n    // Function to add a withdrawal request for a specified LP token amount from a selected pool using a specified plugin.\n    function addWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver, bytes memory payload) external payable nonReentrant whenNotPaused{\n        // Ensure that the vault is not locked before processing withdrawal requests.\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Ensure that the user has provided sufficient execution fee for the withdrawal.\n        require(msg.value >= withdrawMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure a valid and positive LP token amount is provided for withdrawal.\n        require(_lpAmount > 0, \"Vault: Invalid LP token amount\");\n\n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Transfer the specified amount of LP tokens from the user to the contract.\n        this.transferFrom(msg.sender, address(this), _lpAmount);\n\n        // Convert the LP token amount to its equivalent USD value.\n        uint256 usdAmountToWithdraw = convertLPToAsset(_lpAmount);\n\n        // Retrieve information about the selected pool token, including its decimals and price.\n        (, uint8 poolTokenDecimals, ) = getPoolTokenInfo(_pluginId, _poolId);\n\n        // Get the current price of the pool token.\n        uint256 poolTokenPrice = getPoolTokenPrice(_pluginId, _poolId);\n\n        // Calculate the amount of pool tokens equivalent to the USD value of the LP token withdrawal.\n        uint256 poolTokenAmount = convertDecimals(usdAmountToWithdraw, 6, poolTokenDecimals) / poolTokenPrice;\n\n        // Encode the payload for the 'Unstake' action using the specified pool and LP token details.\n        bytes memory _payload = abi.encode(_poolId, poolTokenAmount, _lpAmount, _receiver, payload);\n\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Execute the 'Unstake' action on the plugin with the provided payload.\n        IPlugin(plugin).execute(IPlugin.ActionType.Unstake, _payload);\n\n        emit AddWithdrawalRequest(_lpAmount, _pluginId, _poolId,  _receiver);\n    }\n\n    // Function to get the current price of the pool token for a specified pool using a specified plugin.\n    function getPoolTokenPrice(uint8 _pluginId, uint8 _poolId) public view returns (uint256) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token price.\n        int256 tokenPrice = IPlugin(plugin).getPoolTokenPrice(_poolId, true);\n\n        // Ensure that the retrieved token price is positive.\n        require(tokenPrice > 0, \"Vault: Pool token price is negative.\");\n\n        // Convert the token price to an unsigned integer and return it.\n        return uint256(tokenPrice);\n    }\n\n    // Function to get information about the pool token, including its address, decimals, and balance for a specified pool using a specified plugin.\n    function getPoolTokenInfo(uint8 _pluginId, uint8 _poolId) public view returns (address token, uint8 decimal, uint256 balance) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token information.\n        return IPlugin(plugin).getPoolTokenInfo(_poolId);\n    }\n\n    \n    /* ========== MASTER FUNCTIONS ========== */\n    \n    // Allows the masterContract contract to execute actions on a specified plugin.\n    function execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes memory _payload) public onlyMaster whenNotPaused {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // If the action type is 'Stake', approve tokens for staking according to the payload.\n        if (_actionType == IPlugin.ActionType.Stake) {\n            (, address[] memory _tokens, uint256[] memory _amounts, ) = abi.decode(_payload, (uint8, address[], uint256[], bytes));\n            require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n            // Iterate through the tokens and approve them for staking.\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (_amounts[i] > 0) {\n                    IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n                }\n            }\n        } else if (_actionType == IPlugin.ActionType.Unstake) {\n            ( , , , address receiver, ) = abi.decode(_payload, (uint8, uint256, uint256, address, bytes));\n\n            // Ensure that the receiver address is the vault itself.\n            require(receiver == address(this), \"Invalid receiver\");\n        }\n\n        // Execute the specified action on the plugin with the provided payload.\n        IPlugin(plugin).execute(_actionType, _payload);\n\n        // Emit an event to log the execution of the plugin action.\n        emit Execute(_pluginId, _actionType, _payload);\n    }\n\n    // Allows the masterContract contract to approve tokens for a specified plugin based on the provided payload.\n    function approveTokens(uint8 _pluginId, address[] memory _tokens, uint256[] memory _amounts) external onlyMaster whenNotPaused {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Decode the payload to obtain the list of tokens and corresponding amounts to approve.\n        // (address[] memory _tokens, uint256[] memory _amounts) = abi.decode(_payload, (address[], uint256[]));\n        require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n        // Iterate through the tokens and approve them for the plugin.\n        for (uint256 i; i < _tokens.length; ++i) {\n            IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n        }\n        emit ApproveTokens(_pluginId, _tokens, _amounts);\n    }\n\n    // Updates the liquidity provider rate based on the current market rate.\n    function updateLiquidityProviderRate() internal {\n        // Store the previous liquidity provider rate\n        uint256 previousRate = lpRate;\n        \n        // Calculate the current liquidity provider rate from external source\n        uint256 currentRate = getCurrentLiquidityProviderRate();\n        \n        // Check if the current rate is higher than the previous rate\n        if (currentRate > previousRate) {\n            // Calculate the change in rate and update total profit\n            uint256 deltaRate = currentRate - previousRate;\n        \n            // Calculate total profit in the protocol's base asset\n            uint256 totalProfit = convertDecimals(deltaRate * totalSupply(), 18 + MOZAIC_DECIMALS, ASSET_DECIMALS);\n            \n            // Calculate protocol fee as a percentage of total profit\n            uint256 protocolFee = (totalProfit * protocolFeePercentage) / (BP_DENOMINATOR);\n            \n            // Accumulate protocol fee in the vault\n            protocolFeeInVault += protocolFee;\n\n            // Update the liquidity provider rate\n            lpRate = getCurrentLiquidityProviderRate();\n        } else {\n            // Update the liquidity provider rate directly\n            lpRate = currentRate;\n        }\n\n        // Emit an event to log the update in liquidity provider rate\n        emit UpdateLiquidityProviderRate(previousRate, lpRate);\n    }\n\n    // Withdraws protocol fees stored in the vault for a specific token.\n    function withdrawProtocolFee(address _token) external onlyAdmin whenNotPaused {\n        require(isAcceptedToken(_token), \"Vault: Invalid token\");\n\n        // Calculate the token amount from the protocol fee in the vault\n        uint256 tokenAmount = calculateTokenAmountFromUsd(_token, protocolFeeInVault);\n\n        // Get the token balance of this contract\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n\n        // Determine the transfer amount, ensuring it doesn't exceed the token balance\n        uint256 transferAmount = tokenBalance >= tokenAmount ? tokenAmount : tokenBalance;\n\n        if(tokenAmount != 0) {        \n            // Update the protocol fee in the vault after the withdrawal\n            protocolFeeInVault = protocolFeeInVault - ((protocolFeeInVault * transferAmount) / (tokenAmount));\n\n            // Safely transfer the tokens to the treasury address\n            IERC20(_token).safeTransfer(treasury, transferAmount);\n        }\n        \n        // Emit an event to log the withdrawal\n        emit WithdrawProtocolFee(_token, transferAmount);\n    }\n\n    // Transfers the execution fee to the specified plugin.\n    function transferExecutionFee(uint8 _pluginId, uint256 _amount) external onlyMaster whenNotPaused {\n        // Retrieve information about the specified plugin\n        Plugin memory plugin = getPlugin(_pluginId);\n        \n        // Check if the contract has sufficient balance for the transfer\n        require(_amount <= address(this).balance, \"Vault: Insufficient balance\");\n        \n        // Attempt to transfer Ether to the plugin's address\n        (bool success, ) = plugin.pluginAddress.call{value: _amount}(\"\");\n        \n        // Revert if the Ether transfer to the plugin fails\n        require(success, \"Vault: Failed to send Ether\");\n    }\n \n     function bridgeViaLifi(\n        address _srcToken,\n        uint256 _amount,\n        uint256 _value,\n        bool _bridge,\n        bytes calldata _data\n    ) payable external onlyMaster whenNotPaused {\n\n        if(_bridge) {\n            ( , , address receiver, , uint256 destinationChainId, , ) = ICalldataVerificationFacet(LIFI_CONTRACT).extractMainParameters(_data);\n            lifiWhiteListReceiver memory receiverInfo = lifiReceiverWhiteList[receiver];\n            require(receiverInfo.isWhiteListed &&  receiverInfo.chainId == destinationChainId, \"Vault: Lifi receiver not whitelisted\");\n        } else {\n            ( , , address receiver, , ) = ICalldataVerificationFacet(LIFI_CONTRACT).extractGenericSwapParameters(_data);\n            lifiWhiteListReceiver memory receiverInfo = lifiReceiverWhiteList[receiver];\n            require(receiverInfo.isWhiteListed && receiverInfo.chainId == block.chainid, \"Vault: Lifi receiver not whitelisted\");\n        }\n\n        bool isNative = (_srcToken == address(0));\n        if (!isNative) {           \n            uint256 currentAllowance = IERC20(_srcToken).allowance(address(this), address(LIFI_CONTRACT));\n            if (_amount > currentAllowance) {\n                uint256 increaseAmount = _amount - currentAllowance;\n                IERC20(_srcToken).safeIncreaseAllowance(address(LIFI_CONTRACT), increaseAmount);\n            } else if (_amount < currentAllowance) {\n                uint256 decreaseAmount = currentAllowance - _amount;\n                IERC20(_srcToken).safeDecreaseAllowance(address(LIFI_CONTRACT), decreaseAmount);\n            }\n        }\n        (bool success,) = LIFI_CONTRACT.call{value: _value}(_data);\n        require(success, \"Lifi: call failed\");\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // Retrieve the array of plugins registered in the vault.\n    function getPlugins() public view returns (Plugin[] memory) {\n        return plugins;\n    }\n\n    // Retrieve the total count of registered plugins in the vault.\n    function getPluginsCount() public view returns (uint256) {\n        return plugins.length;\n    }\n\n    // Retrieve details about a specific plugin based on its unique identifier.\n    function getPlugin(uint8 _pluginId) public view returns (Plugin memory) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve and return details about the specified plugin.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n        return plugin;\n    }\n\n    // Retrieves the current liquidity provider rate.\n    function getCurrentLiquidityProviderRate() public view returns(uint256) {\n        uint256 _totalAssets = totalAssetInUsd() > protocolFeeInVault ? totalAssetInUsd() - protocolFeeInVault: 0;\n        \n        // Variable to store the current rate\n        uint256 currentRate;\n\n         // Check if total supply or total assets is zero\n        if (_totalAssets <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            currentRate = 1e18;\n        } else {\n            // Convert total assets to the desired decimals\n            uint256 adjustedAssets = convertDecimals(_totalAssets, ASSET_DECIMALS, MOZAIC_DECIMALS + 18);\n\n            // Calculate the current rate\n            currentRate = adjustedAssets / totalSupply();\n        }\n        return currentRate;\n    }\n\n    // Calculate the total value of assets held by the vault, including liquidity from registered plugins\n    // and the USD value of accepted tokens held in the vault.\n    function totalAssetInUsd() public view returns (uint256 _totalAsset) {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Iterate through registered plugins to calculate their total liquidity.\n        for (uint8 i; i < plugins.length; ++i) {\n            _totalAsset += IPlugin(plugins[i].pluginAddress).getTotalLiquidity();\n        }\n\n        // Iterate through accepted tokens to calculate their total USD value.\n        for (uint256 i; i < acceptedTokens.length; ++i) {\n            // Calculate the USD value of the token based on its balance in the vault.\n            _totalAsset += calculateTokenValueInUsd(acceptedTokens[i], IERC20(acceptedTokens[i]).balanceOf(address(this)));\n        }\n\n        // Return the total calculated asset value.\n        return _totalAsset + 10 ** ASSET_DECIMALS;\n    }\n\n    // Check if a given token is accepted by the vault.\n    function isAcceptedToken(address _token) public view returns (bool) {\n        return acceptedTokenMap[_token];\n    }\n\n    // Check if a given token is allowed for deposit in the vault.\n    function isDepositAllowedToken(address _token) public view returns (bool) {\n        return depositAllowedTokenMap[_token];\n    }\n\n    function getAcceptedTokens() public view returns (address[] memory) {\n        return acceptedTokens;\n    }\n\n    function getDepositAllowedTokens() public view returns (address[] memory) {\n        return depositAllowedTokens;\n    }\n\n    // Retrieve the list of tokens allowed for a specific pool associated with a plugin.\n    // Returns an array of token addresses based on the provided plugin and pool IDs.\n    function getTokensByPluginAndPoolId(uint8 _pluginId, uint8 _poolId) public view returns (address[] memory) {\n        // Initialize an array to store the allowed tokens for the specified pool.\n        address[] memory poolAllowedTokens;\n\n        // If the specified plugin does not exist, return an empty array.\n        if (pluginIdToIndex[_pluginId] == 0) {\n            return poolAllowedTokens;\n        }\n\n        // Retrieve the plugin information based on the provided plugin ID.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n\n        // Retrieve the allowed tokens for the specified pool from the associated plugin.\n        poolAllowedTokens = IPlugin(plugin.pluginAddress).getAllowedTokens(_poolId);\n\n        // Return the array of allowed tokens for the specified pool.\n        return poolAllowedTokens;\n    }\n\n    // Function to get the status of the vault, indicating whether it is locked or unlocked.\n    function getVaultStatus() public view returns (bool) {\n        // Initialize the status as true, assuming the vault is initially unlocked.\n        bool status = true;\n\n        // Iterate through the array of vault lockers to check their individual status.\n        for(uint256 i = 0; i < vaultLockers.length; i++) {\n            // Check the status of the current vault locker.\n            if(IVaultLocker(vaultLockers[i]).getLockerStatus() == false) {\n                // If any vault locker reports that it is locked, set the overall vault status to false and exit the loop.\n                status = false;\n                break;\n            }\n        }\n\n        // Return the overall status of the vault.\n        return status;\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    // Calculate the USD value of a given token amount based on its price and decimals.\n    function calculateTokenValueInUsd(address _tokenAddress, uint256 _tokenAmount) public view returns (uint256) {\n\n        if(_tokenAmount == 0) {\n            return 0;\n        }\n\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = TokenPriceConsumer(tokenPriceConsumer).getTokenDecimal(_tokenAddress);\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Retrieve the token price from the price consumer.\n        uint256 tokenPrice = TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        return convertDecimals(_tokenAmount * tokenPrice, tokenDecimals + priceConsumerDecimals, ASSET_DECIMALS);\n    }\n\n    // Calculate the token amount corresponding to a given USD value based on token price and decimals.\n    function calculateTokenAmountFromUsd(address _tokenAddress, uint256 _tokenValueUsd) public view returns (uint256) {\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = TokenPriceConsumer(tokenPriceConsumer).getTokenDecimal(_tokenAddress);\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Convert the USD value to the desired ASSET_DECIMALS.\n        uint256 normalizedValue = convertDecimals(_tokenValueUsd, ASSET_DECIMALS, tokenDecimals + priceConsumerDecimals);\n\n        // Calculate the token amount based on the normalized value and token price.\n        uint256 tokenAmount = normalizedValue / TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        // Return the calculated token amount.\n        return tokenAmount;\n    }\n\n    /* ========== CONVERT FUNCTIONS ========== */\n\n    // Convert an amount from one decimal precision to another.\n    function convertDecimals(uint256 _amount, uint256 _from, uint256 _to) public pure returns (uint256) {\n        // If the source decimal precision is greater than or equal to the target, perform division.\n        if (_from >= _to) {\n            return _amount / 10 ** (_from - _to);\n        } else {\n            // If the target decimal precision is greater than the source, perform multiplication.\n            return _amount * 10 ** (_to - _from);\n        }\n    }\n\n    // Convert an asset amount to LP tokens based on the current total asset and total LP token supply.\n    function convertAssetToLP(uint256 _amount) public view returns (uint256) {\n        // If the total asset is zero, perform direct decimal conversion.\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, ASSET_DECIMALS, MOZAIC_DECIMALS);\n        }\n        \n        // Perform conversion based on the proportion of the provided amount to the total asset.\n        return (_amount * totalSupply()) / _totalAssetInUsd;\n    }\n\n    // Convert LP tokens to an equivalent asset amount based on the current total asset and total LP token supply.\n    function convertLPToAsset(uint256 _amount) public view returns (uint256) {\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n\n        // If the total LP token supply is zero, perform direct decimal conversion.\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, MOZAIC_DECIMALS, ASSET_DECIMALS);\n        }\n        // Perform conversion based on the proportion of the provided amount to the total LP token supply.\n        return (_amount * _totalAssetInUsd) / totalSupply();\n    }\n\n    // Retrieve the decimal precision of the token (MOZAIC_DECIMALS).\n    function decimals() public view virtual override returns (uint8) {\n        return uint8(MOZAIC_DECIMALS);\n    }\n\n    // Function to get the total supply of the LP tokens, including an additional fixed supply represented by 10^MOZAIC_DECIMALS.\n    function totalSupply() public view virtual override returns (uint256) {\n        // Retrieve the original total supply from the parent contract and add an additional fixed supply.\n        return super.totalSupply() + 10 ** MOZAIC_DECIMALS;\n    }\n\n    // Function to burn a specified amount of LP tokens. Only callable by vault managers.\n    function burnLP(uint256 _lpAmount) external onlyVaultManagers {\n        // Burn the specified amount of LP tokens from the contract's balance.\n        _burn(address(this), _lpAmount);\n    }\n\n    // Function to transfer a specified amount of LP tokens to a given account. Only callable by vault managers.\n    function transferLP(address _account, uint256 _lpAmount) external onlyVaultManagers {\n        // Transfer the specified amount of LP tokens from the contract to the target account.\n        this.transfer(_account, _lpAmount);\n    }\n\n    /* ========== TREASURY FUNCTIONS ========== */\n    receive() external payable {}\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    /* ========== Pausable ========== */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable)\n    {\n        super._update(from, to, value);\n    }\n}"
    },
    "contracts/vaults/TokenPriceConsumer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\ncontract TokenPriceConsumer is Ownable {\n    mapping(address => AggregatorV3Interface) private tokenPriceFeeds;\n    \n    mapping(address => uint256) private tokenHeartbeatDurations;\n\n        \n    mapping(address => uint8) public tokenDecimalList;\n\n    event SetTokenDecimals(address _token, uint8 _decimals);\n\n    constructor(address[] memory tokenAddresses, address[] memory priceFeedAddresses, uint256[] memory heartbeatDurations) Ownable(msg.sender) {\n        require(tokenAddresses.length == priceFeedAddresses.length, \"Arrays length mismatch\");\n        require(tokenAddresses.length == heartbeatDurations.length, \"Arrays length mismatch\");\n\n\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            tokenPriceFeeds[tokenAddresses[i]] = AggregatorV3Interface(priceFeedAddresses[i]);\n            tokenHeartbeatDurations[tokenAddresses[i]] = heartbeatDurations[i];\n        }\n    }\n\n    function addPriceFeed(address tokenAddress, address priceFeedAddress, uint256 heartbeatDuration) public onlyOwner {\n        require(priceFeedAddress != address(0), \"Invalid address\");\n        require(address(tokenPriceFeeds[tokenAddress]) == address(0), \"PriceFeed already exist\");\n        tokenPriceFeeds[tokenAddress] = AggregatorV3Interface(priceFeedAddress);\n        tokenHeartbeatDurations[tokenAddress] = heartbeatDuration;\n\n    }\n\n    function removePriceFeed(address tokenAddress) public onlyOwner {\n        require(address(tokenPriceFeeds[tokenAddress]) != address(0), \"PriceFeed already exist\");\n        delete tokenPriceFeeds[tokenAddress];\n        delete tokenHeartbeatDurations[tokenAddress];\n    }\n\n    function setTokenDecimals(address _token, uint8 _decimals) public onlyOwner {\n        tokenDecimalList[_token] = _decimals;\n\n        emit SetTokenDecimals(_token, _decimals);\n    }\n\n\n    function setTokenDecimalsBatch(address[] calldata _tokens, uint8[] calldata _newDecimals) external onlyOwner {\n        require(_tokens.length == _newDecimals.length, \"Arrays must have the same length\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            setTokenDecimals(_tokens[i], _newDecimals[i]);\n        }\n    }\n\n    function getTokenPrice(address tokenAddress) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n\n        (uint80 roundId, int256 answer, ,uint256 updatedAt  , ) = priceFeed.latestRoundData();\n\n        require(roundId != 0 && answer >= 0 && updatedAt != 0, \"PriceFeed: Sanity check\");\n\n        require(block.timestamp - updatedAt <= tokenHeartbeatDurations[tokenAddress], \"Price feed is stale\");\n        \n        // Token price might need additional scaling based on decimals\n        return uint256(answer);\n    }\n\n    function decimals(address tokenAddress) public view returns (uint8) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n        return priceFeed.decimals();\n    }\n\n    /// @notice The decimals function above returns the number of decimal places used by the price feed. This function is specifically designed to handle non-ERC20 tokens, such as GMX synthetic tokens, which the vault accepts.\n    function getTokenDecimal(address token) public view returns (uint8) {\n        if(isContract(token)) {\n            return IERC20Metadata(token).decimals();\n        } else {\n            uint8 decimalValue = tokenDecimalList[token];\n            require(decimalValue > 0, \"Token decimals not set\");\n            return decimalValue;       \n        }\n    }\n\n    // Public view function to determine whether the given address is a contract or an externally-owned account (EOA).\n    // It uses the assembly block to efficiently check the size of the code at the specified address.\n    // If the size of the code (extcodesize) is greater than 0, the address is considered a contract.\n    // Returns true if the address is a contract and false if it is an externally-owned account.\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n\n        // Use assembly to get the size of the code at the specified address.\n        assembly {\n            size := extcodesize(_addr)\n        }\n\n        // Return true if the size of the code is greater than 0, indicating a contract.\n        return (size > 0);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}