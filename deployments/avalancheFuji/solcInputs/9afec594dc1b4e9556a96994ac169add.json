{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"../../oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce from the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID from the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTMsgCodec {\n    // Offset constants for encoding and decoding OFT messages\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant SEND_AMOUNT_SD_OFFSET = 40;\n\n    /**\n     * @dev Encodes an OFT LayerZero message.\n     * @param _sendTo The recipient address.\n     * @param _amountShared The amount in shared decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded message.\n     * @return hasCompose A boolean indicating whether the message has a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint64 _amountShared,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory _msg, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.\n        _msg = hasCompose\n            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _amountShared);\n    }\n\n    /**\n     * @dev Checks if the OFT message is composed.\n     * @param _msg The OFT message.\n     * @return A boolean indicating whether the message is composed.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > SEND_AMOUNT_SD_OFFSET;\n    }\n\n    /**\n     * @dev Retrieves the recipient address from the OFT message.\n     * @param _msg The OFT message.\n     * @return The recipient address.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the amount in shared decimals from the OFT message.\n     * @param _msg The OFT message.\n     * @return The amount in shared decimals.\n     */\n    function amountSD(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[SEND_TO_OFFSET:SEND_AMOUNT_SD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composed message from the OFT message.\n     * @param _msg The OFT message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[SEND_AMOUNT_SD_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFT Contract\n * @dev OFT is an ERC-20 token that extends the functionality of the OFTCore contract.\n */\nabstract contract OFT is OFTCore, ERC20 {\n    /**\n     * @dev Constructor for the OFT contract.\n     * @param _name The name of the OFT.\n     * @param _symbol The symbol of the OFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC20(_name, _symbol) OFTCore(decimals(), _lzEndpoint, _delegate) {}\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the OFT token.\n     *\n     * @dev In the case of OFT, address(this) and erc20 are the same contract.\n     */\n    function token() public view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of OFT where the contract IS the token, approval is NOT required.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Burns tokens from the sender's specified balance.\n     * @param _from The address to debit the tokens from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n        // @dev In NON-default OFT, amountSentLD could be 100, with a 10% fee, the amountReceivedLD amount is 90,\n        // therefore amountSentLD CAN differ from amountReceivedLD.\n\n        // @dev Default OFT burns on src.\n        _burn(_from, amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        if (_to == address(0x0)) _to = address(0xdead); // _mint(...) does not support address(0x0)\n        // @dev Default OFT mints on dst.\n        _mint(_to, _amountLD);\n        // @dev In the case of NON-default OFT, the _amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata, IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFTAdapter Contract\n * @dev OFTAdapter is a contract that adapts an ERC-20 token to the OFT functionality.\n *\n * @dev For existing ERC20 tokens, this can be used to convert the token to crosschain compatibility.\n * @dev WARNING: ONLY 1 of these should exist for a given global mesh,\n * unless you make a NON-default implementation of OFT and needs to be done very carefully.\n * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n * a pre/post balance check will need to be done to calculate the amountSentLD/amountReceivedLD.\n */\nabstract contract OFTAdapter is OFTCore {\n    using SafeERC20 for IERC20;\n\n    IERC20 internal immutable innerToken;\n\n    /**\n     * @dev Constructor for the OFTAdapter contract.\n     * @param _token The address of the ERC-20 token to be adapted.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) {\n        innerToken = IERC20(_token);\n    }\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the adapted ERC-20 token.\n     *\n     * @dev In the case of OFTAdapter, address(this) and erc20 are NOT the same contract.\n     */\n    function token() public view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of default OFTAdapter, approval is required.\n     * @dev In non-default OFTAdapter contracts with something like mint and burn privileges, it would NOT need approval.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Burns tokens from the sender's specified balance, ie. pull method.\n     * @param _from The address to debit from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev msg.sender will need to approve this _amountLD of tokens to be locked inside of the contract.\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n        // @dev Lock tokens by moving them into this contract from the caller.\n        innerToken.safeTransferFrom(_from, address(this), amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     *\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        // @dev Unlock the tokens and transfer to the recipient.\n        innerToken.safeTransfer(_to, _amountLD);\n        // @dev In the case of NON-default OFTAdapter, the amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { OApp, Origin } from \"../oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"../oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"../oapp/interfaces/IOAppMsgInspector.sol\";\n\nimport { OAppPreCrimeSimulator } from \"../precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IOFT, SendParam, OFTLimit, OFTReceipt, OFTFeeDetail, MessagingReceipt, MessagingFee } from \"./interfaces/IOFT.sol\";\nimport { OFTMsgCodec } from \"./libs/OFTMsgCodec.sol\";\nimport { OFTComposeMsgCodec } from \"./libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title OFTCore\n * @dev Abstract contract for the OftChain (OFT) token.\n */\nabstract contract OFTCore is IOFT, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    // @notice Provides a conversion rate when swapping between denominations of SD and LD\n    //      - shareDecimals == SD == shared Decimals\n    //      - localDecimals == LD == local decimals\n    // @dev Considers that tokens have different decimal amounts on various chains.\n    // @dev eg.\n    //  For a token\n    //      - locally with 4 decimals --> 1.2345 => uint(12345)\n    //      - remotely with 2 decimals --> 1.23 => uint(123)\n    //      - The conversion rate would be 10 ** (4 - 2) = 100\n    //  @dev If you want to send 1.2345 -> (uint 12345), you CANNOT represent that value on the remote,\n    //  you can only display 1.23 -> uint(123).\n    //  @dev To preserve the dust that would otherwise be lost on that conversion,\n    //  we need to unify a denomination that can be represented on ALL chains inside of the OFT mesh\n    uint256 public immutable decimalConversionRate;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_CALL = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _localDecimals The decimals of the token on the local chain (this chain).\n     * @param _endpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(uint8 _localDecimals, address _endpoint, address _delegate) OApp(_endpoint, _delegate) {\n        if (_localDecimals < sharedDecimals()) revert InvalidLocalDecimals();\n        decimalConversionRate = 10 ** (_localDecimals - sharedDecimals());\n    }\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IOFT).interfaceId, 1);\n    }\n\n    /**\n     * @dev Retrieves the shared decimals of the OFT.\n     * @return The shared decimals of the OFT.\n     *\n     * @dev Sets an implicit cap on the amount of tokens, over uint64.max() will need some sort of outbound cap / totalSupply cap\n     * Lowest common decimal denominator between chains.\n     * Defaults to 6 decimal places to provide up to 18,446,744,073,709.551615 units (max uint64).\n     * For tokens exceeding this totalSupply(), they will need to override the sharedDecimals function with something smaller.\n     * ie. 4 sharedDecimals would be 1,844,674,407,370,955.1615\n     */\n    function sharedDecimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     *\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return oftLimit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return oftReceipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        virtual\n        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)\n    {\n        uint256 minAmountLD = 0; // Unused in the default implementation.\n        uint256 maxAmountLD = type(uint64).max; // Unused in the default implementation.\n        oftLimit = OFTLimit(minAmountLD, maxAmountLD);\n\n        // Unused in the default implementation; reserved for future complex fee details.\n        oftFeeDetails = new OFTFeeDetail[](0);\n\n        // @dev This is the same as the send() operation, but without the actual send.\n        // - amountSentLD is the amount in local decimals that would be sent from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to receive, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountReceivedLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @dev Executes the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountSentLD is the amount in local decimals that was ACTUALLY sent/debited from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be received/credited to the recipient on the remote OFT instance.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debit(\n            msg.sender,\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n\n        emit OFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _amountLD The amount in local decimals.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam calldata _sendParam,\n        uint256 _amountLD\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you dont need it on the remote.\n            // EVEN if you dont require an arbitrary payload to be sent... eg. '0x01'\n            _sendParam.composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        if (msgInspector != address(0)) IOAppMsgInspector(msgInspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesnt know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Credit the amountLD to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, _toLD(_message.amountSD()), _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Proprietary composeMsg format for the OFT.\n            bytes memory composeMsg = OFTComposeMsgCodec.encode(\n                _origin.nonce,\n                _origin.srcEid,\n                amountReceivedLD,\n                _message.composeMsg()\n            );\n\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(toAddress, _guid, 0 /* the index of the composed message*/, composeMsg);\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     *\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    /**\n     * @dev Internal function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function _removeDust(uint256 _amountLD) internal view virtual returns (uint256 amountLD) {\n        return (_amountLD / decimalConversionRate) * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from shared decimals into local decimals.\n     * @param _amountSD The amount in shared decimals.\n     * @return amountLD The amount in local decimals.\n     */\n    function _toLD(uint64 _amountSD) internal view virtual returns (uint256 amountLD) {\n        return _amountSD * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from local decimals into shared decimals.\n     * @param _amountLD The amount in local decimals.\n     * @return amountSD The amount in shared decimals.\n     */\n    function _toSD(uint256 _amountLD) internal view virtual returns (uint64 amountSD) {\n        return uint64(_amountLD / decimalConversionRate);\n    }\n\n    /**\n     * @dev Internal function to mock the amount mutation from a OFT debit() operation.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @dev _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent, in local decimals.\n     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.\n     *\n     * @dev This is where things like fees would be calculated and deducted from the amount to be received on the remote.\n     */\n    function _debitView(\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 /*_dstEid*/\n    ) internal view virtual returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        // @dev Remove the dust so nothing is lost on the conversion between chains with different decimals for the token.\n        amountSentLD = _removeDust(_amountLD);\n        // @dev The amount to send is the same as amount received in the default implementation.\n        amountReceivedLD = amountSentLD;\n\n        // @dev Check for slippage.\n        if (amountReceivedLD < _minAmountLD) {\n            revert SlippageExceeded(amountReceivedLD, _minAmountLD);\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a debit operation.\n     * @param _from The address to debit.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual returns (uint256 amountSentLD, uint256 amountReceivedLD);\n\n    /**\n     * @dev Internal function to perform a credit operation.\n     * @param _to The address to credit.\n     * @param _amountLD The amount to credit in local decimals.\n     * @param _srcEid The source endpoint ID.\n     * @return amountReceivedLD The amount ACTUALLY received in local decimals.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual returns (uint256 amountReceivedLD);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/libs/Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/gmx/ICallbackContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICallbackContract {\n    enum State { Deposit, Withdrawal, Order }\n\n    function addKey(bytes32 key, State stateOption) external;\n\n    function getKeys(State stateOption) external view returns(bytes32[] memory);\n\n    function addWithdrawalData(bytes32 withdrawalKey, uint256 lpAmount, address receiver) external;\n}"
    },
    "contracts/interfaces/gmx/IDataStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IDataStore {\n    function getUint(bytes32 key) external view returns (uint256);\n    function setUint(bytes32 key, uint256 value) external returns (uint256);\n    function removeUint(bytes32 key) external;\n    function applyDeltaToUint(bytes32 key, int256 value, string calldata errorMessage) external returns (uint256);\n    function applyDeltaToUint(bytes32 key, uint256 value) external returns (uint256);\n    function applyBoundedDeltaToUint(bytes32 key, int256 value) external returns (uint256);\n    function incrementUint(bytes32 key, uint256 value) external returns (uint256);\n    function decrementUint(bytes32 key, uint256 value) external returns (uint256);\n\n    function getInt(bytes32 key) external view returns (int256);\n    function setInt(bytes32 key, int256 value) external returns (int256);\n    function removeInt(bytes32 key) external;\n    function applyDeltaToInt(bytes32 key, int256 value) external returns (int256);\n    function incrementInt(bytes32 key, int256 value) external returns (int256);\n    function decrementInt(bytes32 key, int256 value) external returns (int256);\n\n    function getAddress(bytes32 key) external view returns (address);\n    function setAddress(bytes32 key, address value) external returns (address);\n    function removeAddress(bytes32 key) external;\n\n    function getBool(bytes32 key) external view returns (bool);\n    function setBool(bytes32 key, bool value) external returns (bool);\n    function removeBool(bytes32 key) external;\n\n    function getString(bytes32 key) external view returns (string memory);\n    function setString(bytes32 key, string calldata value) external returns (string memory);\n    function removeString(bytes32 key) external;\n\n    function getBytes32(bytes32 key) external view returns (bytes32);\n    function setBytes32(bytes32 key, bytes32 value) external returns (bytes32);\n    function removeBytes32(bytes32 key) external;\n\n    function getUintArray(bytes32 key) external view returns (uint256[] memory);\n    function setUintArray(bytes32 key, uint256[] memory value) external;\n    function removeUintArray(bytes32 key) external;\n\n    function getIntArray(bytes32 key) external view returns (int256[] memory);\n    function setIntArray(bytes32 key, int256[] memory value) external;\n    function removeIntArray(bytes32 key) external;\n\n    function getAddressArray(bytes32 key) external view returns (address[] memory);\n    function setAddressArray(bytes32 key, address[] memory value) external;\n    function removeAddressArray(bytes32 key) external;\n\n    function getBoolArray(bytes32 key) external view returns (bool[] memory);\n    function setBoolArray(bytes32 key, bool[] memory value) external;\n    function removeBoolArray(bytes32 key) external;\n\n    function getStringArray(bytes32 key) external view returns (string[] memory);\n    function setStringArray(bytes32 key, string[] memory value) external;\n    function removeStringArray(bytes32 key) external;\n\n    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory);\n    function setBytes32Array(bytes32 key, bytes32[] memory value) external;\n    function removeBytes32Array(bytes32 key) external;\n\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);\n    function getBytes32Count(bytes32 setKey) external view returns (uint256);\n    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory);\n    function addBytes32(bytes32 setKey, bytes32 value) external;\n    function removeBytes32(bytes32 setKey, bytes32 value) external;\n\n    function containsAddress(bytes32 setKey, address value) external view returns (bool);\n    function getAddressCount(bytes32 setKey) external view returns (uint256);\n    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory);\n    function addAddress(bytes32 setKey, address value) external;\n    function removeAddress(bytes32 setKey, address value) external;\n\n    function containsUint(bytes32 setKey, uint256 value) external view returns (bool);\n    function getUintCount(bytes32 setKey) external view returns (uint256);\n    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory);\n    function addUint(bytes32 setKey, uint256 value) external;\n    function removeUint(bytes32 setKey, uint256 value) external;\n}"
    },
    "contracts/interfaces/gmx/IDepositCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/gmx/EventUtils.sol\";\nimport \"../../libraries/gmx/Deposit.sol\";\n\n// @title IDepositCallbackReceiver\n// @dev interface for a deposit callback contract\ninterface IDepositCallbackReceiver {\n    // @dev called after a deposit execution\n    // @param key the key of the deposit\n    // @param deposit the deposit that was executed\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after a deposit cancellation\n    // @param key the key of the deposit\n    // @param deposit the deposit that was cancelled\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n}"
    },
    "contracts/interfaces/gmx/IExchangeRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"./IDataStore.sol\"; // Import the DataStore contract\n\ninterface IExchangeRouter {\n    \n    function dataStore() external view returns (IDataStore);\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n    \n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n\n    enum OrderType {\n        // @dev MarketSwap: swap token A to token B at the current market price\n        // the order will be cancelled if the minOutputAmount cannot be fulfilled\n        MarketSwap,\n        // @dev LimitSwap: swap token A to token B if the minOutputAmount can be fulfilled\n        LimitSwap,\n        // @dev MarketIncrease: increase position at the current market price\n        // the order will be cancelled if the position cannot be increased at the acceptablePrice\n        MarketIncrease,\n        // @dev LimitIncrease: increase position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitIncrease,\n        // @dev MarketDecrease: decrease position at the current market price\n        // the order will be cancelled if the position cannot be decreased at the acceptablePrice\n        MarketDecrease,\n        // @dev LimitDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitDecrease,\n        // @dev StopLossDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        StopLossDecrease,\n        // @dev Liquidation: allows liquidation of positions if the criteria for liquidation are met\n        Liquidation\n    }\n\n    enum DecreasePositionSwapType {\n        NoSwap,\n        SwapPnlTokenToCollateralToken,\n        SwapCollateralTokenToPnlToken\n    }\n\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        OrderType orderType;\n        DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev Wraps the specified amount of native tokens into WNT then sends the WNT to the specified address\n    function sendWnt(address receiver, uint256 amount) external payable;\n\n    // @dev Sends the given amount of tokens to the given address\n    function sendTokens(address token, address receiver, uint256 amount) external payable;\n\n    function createDeposit(\n        CreateDepositParams calldata params\n    ) external payable returns (bytes32);\n\n    function createWithdrawal(\n        CreateWithdrawalParams calldata params\n    ) external payable returns (bytes32);\n\n    function createOrder(\n        CreateOrderParams calldata params\n    ) external payable returns (bytes32);\n\n    function cancelDeposit(bytes32 key) external payable;\n    function cancelWithdrawal(bytes32 key) external payable;\n    function cancelOrder(bytes32 key) external payable;\n}"
    },
    "contracts/interfaces/gmx/IMarket.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IMarket {\n    struct Props {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}"
    },
    "contracts/interfaces/gmx/IMarketPoolValueInfo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IMarketPoolValueInfo {\n    struct Props {\n        int256 poolValue;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeePoolFactor;\n\n        uint256 impactPoolAmount;\n    }\n}"
    },
    "contracts/interfaces/gmx/IOrderCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/gmx/EventUtils.sol\";\nimport \"../../libraries/gmx/Order.sol\";\n\n// @title IOrderCallbackReceiver\n// @dev interface for an order callback contract\ninterface IOrderCallbackReceiver {\n    // @dev called after an order execution\n    // @param key the key of the order\n    // @param order the order that was executed\n    function afterOrderExecution(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after an order cancellation\n    // @param key the key of the order\n    // @param order the order that was cancelled\n    function afterOrderCancellation(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after an order has been frozen, see OrderUtils.freezeOrder in OrderHandler for more info\n    // @param key the key of the order\n    // @param order the order that was frozen\n    function afterOrderFrozen(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n}"
    },
    "contracts/interfaces/gmx/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPlugin {\n    function transferAllTokensToVault() external;\n}"
    },
    "contracts/interfaces/gmx/IReader.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"./IDataStore.sol\"; // Import the DataStore contract\nimport \"./IMarket.sol\"; // Import the Market contract\nimport \"./IMarketPoolValueInfo.sol\"; // Import the MarketPoolValueInfo contract\nimport \"../IPrice.sol\"; // Import the Price contract\n\ninterface IReader {\n    function getMarketTokenPrice(\n        IDataStore dataStore,\n        IMarket.Props memory market,\n        IPrice.Props memory indexTokenPrice,\n        IPrice.Props memory longTokenPrice,\n        IPrice.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, IMarketPoolValueInfo.Props memory);\n}"
    },
    "contracts/interfaces/gmx/IWithdrawalCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../../libraries/gmx/EventUtils.sol\";\nimport \"../../libraries/gmx//Withdrawal.sol\";\n\n// @title IWithdrawalCallbackReceiver\n// @dev interface for a withdrawal callback contract\ninterface IWithdrawalCallbackReceiver {\n    // @dev called after a withdrawal execution\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was executed\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after a withdrawal cancellation\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was cancelled\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n}"
    },
    "contracts/interfaces/IPrice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPrice {\n    struct Props {\n        uint256 min;\n        uint256 max;\n    }\n}"
    },
    "contracts/interfaces/tokens/IMozToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMozToken is IERC20 {\n\tfunction burn(uint256 amount, address from) external;\n\tfunction mint(uint256 amount, address to) external;\n}"
    },
    "contracts/interfaces/tokens/IXMozToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IXMozToken is IERC20 {\n\n    function mint(uint256 amount, address to) external;\n\n    function isTransferWhitelisted(address account) external view returns (bool);\n\n    function burn(uint256 amount, address to) external;\n\n    function updateTransferWhitelist(address account, bool flag) external;\n\n}"
    },
    "contracts/interfaces/vaults/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @dev Interface of the Plugin standard.\n */\ninterface IPlugin {\n    enum ActionType {\n        // Action types\n        Stake,\n        Unstake,\n        SwapTokens,\n        ClaimRewards,\n        CancelAction\n    }\n\n    function execute(ActionType _actionType, bytes calldata _payload) external payable;\n    \n    function getTotalLiquidity() external view returns (uint256);\n\n    function getPoolNumber() external view returns(uint256);\n\n    function getAllowedTokens(uint8 _poolId) external view returns (address[] memory tokens);\n\n    function getPoolTokenPrice(uint8 _poolId, bool _maximize) external view returns (int256);\n\n    function getPoolTokenInfo(uint8 _poolId) external view returns (address token, uint8 decimal, uint256 balance);\n}\n"
    },
    "contracts/interfaces/vaults/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n\ninterface IVault {\n    function burnLP(uint256 _lpAmount) external;\n    function transferLP(address _account, uint256 _lpAmount) external;\n}"
    },
    "contracts/interfaces/vaults/IVaultLocker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n\ninterface IVaultLocker {\n    function getLockerStatus() external view returns(bool);\n}"
    },
    "contracts/libraries/gmx/ArbSys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title ArbSys\n// @dev Globally available variables for Arbitrum may have both an L1 and an L2\n// value, the ArbSys interface is used to retrieve the L2 value\ninterface ArbSys {\n    function arbBlockNumber() external view returns (uint256);\n    function arbBlockHash(uint256 blockNumber) external view returns (bytes32);\n}"
    },
    "contracts/libraries/gmx/Chain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./ArbSys.sol\";\n\n// @title Chain\n// @dev Wrap the calls to retrieve chain variables to handle differences\n// between chain implementations\nlibrary Chain {\n    // if the ARBITRUM_CHAIN_ID changes, a new version of this library\n    // and contracts depending on it would need to be deployed\n    uint256 public constant ARBITRUM_CHAIN_ID = 42161;\n    uint256 public constant ARBITRUM_SEPOLIA_CHAIN_ID = 421614;\n\n    ArbSys public constant arbSys = ArbSys(address(100));\n\n    // @dev return the current block's timestamp\n    // @return the current block's timestamp\n    function currentTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // @dev return the current block's number\n    // @return the current block's number\n    function currentBlockNumber() internal view returns (uint256) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    // @dev return the current block's hash\n    // @return the current block's hash\n    function getBlockHash(uint256 blockNumber) internal view returns (bytes32) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockHash(blockNumber);\n        }\n\n        return blockhash(blockNumber);\n    }\n\n    function shouldUseArbSysValues() internal view returns (bool) {\n        return block.chainid == ARBITRUM_CHAIN_ID || block.chainid == ARBITRUM_SEPOLIA_CHAIN_ID;\n    }\n}"
    },
    "contracts/libraries/gmx/Deposit.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Deposit\n// @dev Struct for deposits\nlibrary Deposit {\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account depositing liquidity\n    // @param receiver the address to send the liquidity tokens to\n    // @param callbackContract the callback contract\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the market to deposit to\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n    // @param initialLongTokenAmount the amount of long tokens to deposit\n    // @param initialShortTokenAmount the amount of short tokens to deposit\n    // @param minMarketTokens the minimum acceptable number of liquidity tokens\n    // @param updatedAtBlock the block that the deposit was last updated at\n    // sending funds back to the user in case the deposit gets cancelled\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    struct Numbers {\n        uint256 initialLongTokenAmount;\n        uint256 initialShortTokenAmount;\n        uint256 minMarketTokens;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    function initialLongToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialLongToken;\n    }\n\n    function setInitialLongToken(Props memory props, address value) internal pure {\n        props.addresses.initialLongToken = value;\n    }\n\n    function initialShortToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialShortToken;\n    }\n\n    function setInitialShortToken(Props memory props, address value) internal pure {\n        props.addresses.initialShortToken = value;\n    }\n\n    function longTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.longTokenSwapPath;\n    }\n\n    function setLongTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.longTokenSwapPath = value;\n    }\n\n    function shortTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.shortTokenSwapPath;\n    }\n\n    function setShortTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.shortTokenSwapPath = value;\n    }\n\n    function initialLongTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialLongTokenAmount;\n    }\n\n    function setInitialLongTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialLongTokenAmount = value;\n    }\n\n    function initialShortTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialShortTokenAmount;\n    }\n\n    function setInitialShortTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialShortTokenAmount = value;\n    }\n\n    function minMarketTokens(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minMarketTokens;\n    }\n\n    function setMinMarketTokens(Props memory props, uint256 value) internal pure {\n        props.numbers.minMarketTokens = value;\n    }\n\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n}"
    },
    "contracts/libraries/gmx/EventUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary EventUtils {\n    struct EmitPositionDecreaseParams {\n        bytes32 key;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n    }\n\n    struct EventLogData {\n        AddressItems addressItems;\n        UintItems uintItems;\n        IntItems intItems;\n        BoolItems boolItems;\n        Bytes32Items bytes32Items;\n        BytesItems bytesItems;\n        StringItems stringItems;\n    }\n\n    struct AddressItems {\n        AddressKeyValue[] items;\n        AddressArrayKeyValue[] arrayItems;\n    }\n\n    struct UintItems {\n        UintKeyValue[] items;\n        UintArrayKeyValue[] arrayItems;\n    }\n\n    struct IntItems {\n        IntKeyValue[] items;\n        IntArrayKeyValue[] arrayItems;\n    }\n\n    struct BoolItems {\n        BoolKeyValue[] items;\n        BoolArrayKeyValue[] arrayItems;\n    }\n\n    struct Bytes32Items {\n        Bytes32KeyValue[] items;\n        Bytes32ArrayKeyValue[] arrayItems;\n    }\n\n    struct BytesItems {\n        BytesKeyValue[] items;\n        BytesArrayKeyValue[] arrayItems;\n    }\n\n    struct StringItems {\n        StringKeyValue[] items;\n        StringArrayKeyValue[] arrayItems;\n    }\n\n    struct AddressKeyValue {\n        string key;\n        address value;\n    }\n\n    struct AddressArrayKeyValue {\n        string key;\n        address[] value;\n    }\n\n    struct UintKeyValue {\n        string key;\n        uint256 value;\n    }\n\n    struct UintArrayKeyValue {\n        string key;\n        uint256[] value;\n    }\n\n    struct IntKeyValue {\n        string key;\n        int256 value;\n    }\n\n    struct IntArrayKeyValue {\n        string key;\n        int256[] value;\n    }\n\n    struct BoolKeyValue {\n        string key;\n        bool value;\n    }\n\n    struct BoolArrayKeyValue {\n        string key;\n        bool[] value;\n    }\n\n    struct Bytes32KeyValue {\n        string key;\n        bytes32 value;\n    }\n\n    struct Bytes32ArrayKeyValue {\n        string key;\n        bytes32[] value;\n    }\n\n    struct BytesKeyValue {\n        string key;\n        bytes value;\n    }\n\n    struct BytesArrayKeyValue {\n        string key;\n        bytes[] value;\n    }\n\n    struct StringKeyValue {\n        string key;\n        string value;\n    }\n\n    struct StringArrayKeyValue {\n        string key;\n        string[] value;\n    }\n\n    function initItems(AddressItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.AddressKeyValue[](size);\n    }\n\n    function initArrayItems(AddressItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.AddressArrayKeyValue[](size);\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(UintItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.UintKeyValue[](size);\n    }\n\n    function initArrayItems(UintItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.UintArrayKeyValue[](size);\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(IntItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.IntKeyValue[](size);\n    }\n\n    function initArrayItems(IntItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.IntArrayKeyValue[](size);\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BoolItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BoolKeyValue[](size);\n    }\n\n    function initArrayItems(BoolItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BoolArrayKeyValue[](size);\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.items = new EventUtils.Bytes32KeyValue[](size);\n    }\n\n    function initArrayItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.Bytes32ArrayKeyValue[](size);\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BytesItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BytesKeyValue[](size);\n    }\n\n    function initArrayItems(BytesItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BytesArrayKeyValue[](size);\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(StringItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.StringKeyValue[](size);\n    }\n\n    function initArrayItems(StringItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.StringArrayKeyValue[](size);\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n}"
    },
    "contracts/libraries/gmx/Order.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Chain.sol\";\n\n// @title Order\n// @dev Struct for orders\nlibrary Order {\n    using Order for Props;\n\n    enum OrderType {\n        // @dev MarketSwap: swap token A to token B at the current market price\n        // the order will be cancelled if the minOutputAmount cannot be fulfilled\n        MarketSwap,\n        // @dev LimitSwap: swap token A to token B if the minOutputAmount can be fulfilled\n        LimitSwap,\n        // @dev MarketIncrease: increase position at the current market price\n        // the order will be cancelled if the position cannot be increased at the acceptablePrice\n        MarketIncrease,\n        // @dev LimitIncrease: increase position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitIncrease,\n        // @dev MarketDecrease: decrease position at the current market price\n        // the order will be cancelled if the position cannot be decreased at the acceptablePrice\n        MarketDecrease,\n        // @dev LimitDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitDecrease,\n        // @dev StopLossDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        StopLossDecrease,\n        // @dev Liquidation: allows liquidation of positions if the criteria for liquidation are met\n        Liquidation\n    }\n\n    // to help further differentiate orders\n    enum SecondaryOrderType {\n        None,\n        Adl\n    }\n\n    enum DecreasePositionSwapType {\n        NoSwap,\n        SwapPnlTokenToCollateralToken,\n        SwapCollateralTokenToPnlToken\n    }\n\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account of the order\n    // @param receiver the receiver for any token transfers\n    // this field is meant to allow the output of an order to be\n    // received by an address that is different from the creator of the\n    // order whether this is for swaps or whether the account is the owner\n    // of a position\n    // for funding fees and claimable collateral, the funds are still\n    // credited to the owner of the position indicated by order.account\n    // @param callbackContract the contract to call for callbacks\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the trading market\n    // @param initialCollateralToken for increase orders, initialCollateralToken\n    // is the token sent in by the user, the token will be swapped through the\n    // specified swapPath, before being deposited into the position as collateral\n    // for decrease orders, initialCollateralToken is the collateral token of the position\n    // withdrawn collateral from the decrease of the position will be swapped\n    // through the specified swapPath\n    // for swaps, initialCollateralToken is the initial token sent for the swap\n    // @param swapPath an array of market addresses to swap through\n    struct Addresses {\n        address account;\n        address receiver;\n        address cancellationReceiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd the requested change in position size\n    // @param initialCollateralDeltaAmount for increase orders, initialCollateralDeltaAmount\n    // is the amount of the initialCollateralToken sent in by the user\n    // for decrease orders, initialCollateralDeltaAmount is the amount of the position's\n    // collateralToken to withdraw\n    // for swaps, initialCollateralDeltaAmount is the amount of initialCollateralToken sent\n    // in for the swap\n    // @param orderType the order type\n    // @param triggerPrice the trigger price for non-market orders\n    // @param acceptablePrice the acceptable execution price for increase / decrease orders\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    // @param minOutputAmount the minimum output amount for decrease orders and swaps\n    // note that for decrease orders, multiple tokens could be received, for this reason, the\n    // minOutputAmount value is treated as a USD value for validation in decrease orders\n    // @param updatedAtBlock the block at which the order was last updated\n    struct Numbers {\n        OrderType orderType;\n        DecreasePositionSwapType decreasePositionSwapType;\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n    }\n\n    // @param isLong whether the order is for a long or short\n    // @param shouldUnwrapNativeToken whether to unwrap native tokens before\n    // transferring to the user\n    // @param isFrozen whether the order is frozen\n    struct Flags {\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bool isFrozen;\n        bool autoCancel;\n    }\n\n    // @dev the order account\n    // @param props Props\n    // @return the order account\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    // @dev set the order account\n    // @param props Props\n    // @param value the value to set to\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    // @dev the order receiver\n    // @param props Props\n    // @return the order receiver\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    // @dev set the order receiver\n    // @param props Props\n    // @param value the value to set to\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function cancellationReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.cancellationReceiver;\n    }\n\n    function setCancellationReceiver(Props memory props, address value) internal pure {\n        props.addresses.cancellationReceiver = value;\n    }\n\n    // @dev the order callbackContract\n    // @param props Props\n    // @return the order callbackContract\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    // @dev set the order callbackContract\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    // @dev the order market\n    // @param props Props\n    // @return the order market\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    // @dev set the order market\n    // @param props Props\n    // @param value the value to set to\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    // @dev the order initialCollateralToken\n    // @param props Props\n    // @return the order initialCollateralToken\n    function initialCollateralToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialCollateralToken;\n    }\n\n    // @dev set the order initialCollateralToken\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralToken(Props memory props, address value) internal pure {\n        props.addresses.initialCollateralToken = value;\n    }\n\n    // @dev the order uiFeeReceiver\n    // @param props Props\n    // @return the order uiFeeReceiver\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    // @dev set the order uiFeeReceiver\n    // @param props Props\n    // @param value the value to set to\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    // @dev the order swapPath\n    // @param props Props\n    // @return the order swapPath\n    function swapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.swapPath;\n    }\n\n    // @dev set the order swapPath\n    // @param props Props\n    // @param value the value to set to\n    function setSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.swapPath = value;\n    }\n\n    // @dev the order type\n    // @param props Props\n    // @return the order type\n    function orderType(Props memory props) internal pure returns (OrderType) {\n        return props.numbers.orderType;\n    }\n\n    // @dev set the order type\n    // @param props Props\n    // @param value the value to set to\n    function setOrderType(Props memory props, OrderType value) internal pure {\n        props.numbers.orderType = value;\n    }\n\n    function decreasePositionSwapType(Props memory props) internal pure returns (DecreasePositionSwapType) {\n        return props.numbers.decreasePositionSwapType;\n    }\n\n    function setDecreasePositionSwapType(Props memory props, DecreasePositionSwapType value) internal pure {\n        props.numbers.decreasePositionSwapType = value;\n    }\n\n    // @dev the order sizeDeltaUsd\n    // @param props Props\n    // @return the order sizeDeltaUsd\n    function sizeDeltaUsd(Props memory props) internal pure returns (uint256) {\n        return props.numbers.sizeDeltaUsd;\n    }\n\n    // @dev set the order sizeDeltaUsd\n    // @param props Props\n    // @param value the value to set to\n    function setSizeDeltaUsd(Props memory props, uint256 value) internal pure {\n        props.numbers.sizeDeltaUsd = value;\n    }\n\n    // @dev the order initialCollateralDeltaAmount\n    // @param props Props\n    // @return the order initialCollateralDeltaAmount\n    function initialCollateralDeltaAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialCollateralDeltaAmount;\n    }\n\n    // @dev set the order initialCollateralDeltaAmount\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralDeltaAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialCollateralDeltaAmount = value;\n    }\n\n    // @dev the order triggerPrice\n    // @param props Props\n    // @return the order triggerPrice\n    function triggerPrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.triggerPrice;\n    }\n\n    // @dev set the order triggerPrice\n    // @param props Props\n    // @param value the value to set to\n    function setTriggerPrice(Props memory props, uint256 value) internal pure {\n        props.numbers.triggerPrice = value;\n    }\n\n    // @dev the order acceptablePrice\n    // @param props Props\n    // @return the order acceptablePrice\n    function acceptablePrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.acceptablePrice;\n    }\n\n    // @dev set the order acceptablePrice\n    // @param props Props\n    // @param value the value to set to\n    function setAcceptablePrice(Props memory props, uint256 value) internal pure {\n        props.numbers.acceptablePrice = value;\n    }\n\n    // @dev set the order executionFee\n    // @param props Props\n    // @param value the value to set to\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    // @dev the order executionFee\n    // @param props Props\n    // @return the order executionFee\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    // @dev the order callbackGasLimit\n    // @param props Props\n    // @return the order callbackGasLimit\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    // @dev set the order callbackGasLimit\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    // @dev the order minOutputAmount\n    // @param props Props\n    // @return the order minOutputAmount\n    function minOutputAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minOutputAmount;\n    }\n\n    // @dev set the order minOutputAmount\n    // @param props Props\n    // @param value the value to set to\n    function setMinOutputAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minOutputAmount = value;\n    }\n\n    // @dev the order updatedAtBlock\n    // @param props Props\n    // @return the order updatedAtBlock\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    // @dev set the order updatedAtBlock\n    // @param props Props\n    // @param value the value to set to\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    // @dev the order updatedAtTime\n    // @param props Props\n    // @return the order updatedAtTime\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    // @dev set the order updatedAtTime\n    // @param props Props\n    // @param value the value to set to\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    // @dev whether the order is for a long or short\n    // @param props Props\n    // @return whether the order is for a long or short\n    function isLong(Props memory props) internal pure returns (bool) {\n        return props.flags.isLong;\n    }\n\n    // @dev set whether the order is for a long or short\n    // @param props Props\n    // @param value the value to set to\n    function setIsLong(Props memory props, bool value) internal pure {\n        props.flags.isLong = value;\n    }\n\n    // @dev whether to unwrap the native token before transfers to the user\n    // @param props Props\n    // @return whether to unwrap the native token before transfers to the user\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    // @dev set whether the native token should be unwrapped before being\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n\n    // @dev whether the order is frozen\n    // @param props Props\n    // @return whether the order is frozen\n    function isFrozen(Props memory props) internal pure returns (bool) {\n        return props.flags.isFrozen;\n    }\n\n    // @dev set whether the order is frozen\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setIsFrozen(Props memory props, bool value) internal pure {\n        props.flags.isFrozen = value;\n    }\n\n    function autoCancel(Props memory props) internal pure returns (bool) {\n        return props.flags.autoCancel;\n    }\n\n    function setAutoCancel(Props memory props, bool value) internal pure {\n        props.flags.autoCancel = value;\n    }\n\n    // @dev set the order.updatedAtBlock to the current block number\n    // @param props Props\n    function touch(Props memory props) internal view {\n        props.setUpdatedAtBlock(Chain.currentBlockNumber());\n        props.setUpdatedAtTime(Chain.currentTimestamp());\n    }\n}"
    },
    "contracts/libraries/gmx/Withdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Withdrawal\n * @dev Struct for withdrawals\n */\nlibrary Withdrawal {\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n     // @param account The account to withdraw for.\n     // @param receiver The address that will receive the withdrawn tokens.\n     // @param callbackContract The contract that will be called back.\n     // @param uiFeeReceiver The ui fee receiver.\n     // @param market The market on which the withdrawal will be executed.\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n     // @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     // @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     // @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     // @param updatedAtBlock The block at which the withdrawal was last updated.\n     // @param executionFee The execution fee for the withdrawal.\n     // @param callbackGasLimit The gas limit for calling the callback contract.\n    struct Numbers {\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    function longTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.longTokenSwapPath;\n    }\n\n    function setLongTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.longTokenSwapPath = value;\n    }\n\n    function shortTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.shortTokenSwapPath;\n    }\n\n    function setShortTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.shortTokenSwapPath = value;\n    }\n\n    function marketTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.marketTokenAmount;\n    }\n\n    function setMarketTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.marketTokenAmount = value;\n    }\n\n    function minLongTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minLongTokenAmount;\n    }\n\n    function setMinLongTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minLongTokenAmount = value;\n    }\n\n    function minShortTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minShortTokenAmount;\n    }\n\n    function setMinShortTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minShortTokenAmount = value;\n    }\n\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n}"
    },
    "contracts/tokens/MozStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IMozToken } from \"../interfaces/tokens/IMozToken.sol\";\nimport { IXMozToken } from \"../interfaces/tokens/IXMozToken.sol\";\n\n/*\n * MozStaking is Mozaic's escrowed governance token obtainable by converting MOZ to it\n * It's non-transferable, except from/to whitelisted addresses\n * It can be converted back to MOZ through a vesting process\n * This contract is made to receive MozStaking deposits from users in order to allocate them to Usages (plugins) contracts\n */\ncontract MozStaking is Ownable {\n    \n    using Address for address;\n    using SafeERC20 for IMozToken;\n    using SafeERC20 for IXMozToken;\n\n    struct RedeemInfo {\n        uint256 mozAmount; // MOZ amount to receive when vesting has ended\n        uint256 xMozAmount; // xMOZ amount to redeem\n        uint256 endTime;\n    }\n\n    IMozToken public mozaicToken; // MOZ token to convert to/from\n    IXMozToken public xMozToken;\n    address public daoTreasury;\n    bool private flag;\n    uint256 public constant MAX_FIXED_RATIO = 100; // 100%\n\n    // Redeeming min/max settings\n    uint256 public minRedeemRatio = 50; // 1:0.5\n    uint256 public mediumRedeemRatio = 75; // 1:0.75\n    uint256 public maxRedeemRatio = 100; // 1:1\n    uint256 public minRedeemDuration = 15 days; // 1,296,000s\n    uint256 public mediumRedeemDuration = 30 days; // 2,592,000s\n    uint256 public maxRedeemDuration = 45 days; // 3,888,000s\n\n    mapping(address => uint256) public xMozRedeemingBalances; // User's xMOZ balances\n    mapping(address => RedeemInfo[]) public userRedeems; // User's redeeming instances\n\n    /**\n     * @custom:security-contact mailto:security@mozaic.finance\n     */\n\n    constructor(address daoTreasury_) Ownable(msg.sender)\n    {\n        require(daoTreasury_ != address(0x0), \"Invalid addr\");\n        daoTreasury = daoTreasury_;\n    }\n\n    /********************************************/\n    /****************** EVENTS ******************/\n    /********************************************/\n\n    event Convert(address indexed from, address to, uint256 amount);\n    event UpdateRedeemSettings(uint256 minRedeemRatio, uint256 mediumRedeemRatio, uint256 maxRedeemRatio, uint256 minRedeemDuration, uint256 mediumRedeemDuration, uint256 maxRedeemDuration);\n    event Redeem(address indexed userAddress, uint256 xMozAmount, uint256 mozAmount, uint256 duration);\n    event FinalizeRedeem(address indexed userAddress, uint256 xMozAmount, uint256 mozAmount);\n    event CancelRedeem(address indexed userAddress, uint256 xMozAmount);\n\n    /***********************************************/\n    /****************** MODIFIERS ******************/\n    /***********************************************/\n\n    /**\n    * @dev Check if a redeem entry exists\n    */\n    modifier validateRedeem(address userAddress, uint256 redeemIndex) {\n        require(redeemIndex < userRedeems[userAddress].length, \"validateRedeem: redeem entry does not exist\");\n        _;\n    }\n\n    /**************************************************/\n    /******************* INITIALIZE* ******************/\n    /**************************************************/\n\n    /**\n    * @dev Initialize contract parameters\n     */\n    function initialize(address mozaicToken_, address xMoztoken_) external onlyOwner() {\n        require(mozaicToken_ != address(0x0) || xMoztoken_ != address(0x0), \"Invalid addr\");\n        require(!flag, \"Already initialized\");\n        mozaicToken = IMozToken(mozaicToken_);\n        xMozToken = IXMozToken(xMoztoken_);\n        flag = true;\n    }\n\n    /**************************************************/\n    /****************** PUBLIC VIEWS ******************/\n    /**************************************************/\n\n    /**\n    * @dev Returns user's xMOZ balances\n    */\n    function getRedeemingXMozBalance(address userAddress) external view returns (uint256 redeemingAmount) {\n        uint256 balance = xMozRedeemingBalances[userAddress];\n        return balance;\n    }\n\n    /**\n    * @dev returns redeemable MOZ for \"amount\" of xMOZ vested for \"duration\" seconds\n    */\n    function getMozByVestingDuration(uint256 amount, uint256 duration) public view returns (uint256) {\n        uint256 ratio;\n        \n        if(duration < minRedeemDuration) {\n            return 0;\n        }\n        else if(duration >= minRedeemDuration && duration < mediumRedeemDuration) {\n            ratio = minRedeemRatio + (mediumRedeemRatio - minRedeemRatio) * (duration - minRedeemDuration) / (mediumRedeemDuration - minRedeemDuration);\n        }\n        else if(duration >= mediumRedeemDuration && duration < maxRedeemDuration) {\n            ratio = mediumRedeemRatio + (maxRedeemRatio - mediumRedeemRatio) * (duration - mediumRedeemDuration) / (maxRedeemDuration - mediumRedeemDuration);\n        }\n        // capped to maxRedeemDuration\n        else {\n            ratio = maxRedeemRatio;\n        }\n\n        return amount * ratio / MAX_FIXED_RATIO;\n    }\n\n    /**\n    * @dev returns quantity of \"userAddress\" pending redeems\n    */\n    function getUserRedeemsLength(address userAddress) external view returns (uint256) {\n        return userRedeems[userAddress].length;\n    }\n\n    /**\n    * @dev returns \"userAddress\" info for a pending redeem identified by \"redeemIndex\"\n    */\n    function getUserRedeem(address userAddress, uint256 redeemIndex) external view validateRedeem(userAddress, redeemIndex) returns (uint256 mozAmount, uint256 xMozAmount, uint256 endTime) {\n        RedeemInfo storage _redeem = userRedeems[userAddress][redeemIndex];\n        return (_redeem.mozAmount, _redeem.xMozAmount, _redeem.endTime);\n    }\n\n    /*******************************************************/\n    /****************** OWNABLE FUNCTIONS ******************/\n    /*******************************************************/\n\n    /**\n    * @dev Updates all redeem ratios and durations\n    *\n    * Must only be called by owner\n    */\n    function updateRedeemSettings(uint256 minRedeemRatio_, uint256 mediumRedeemRatio_, uint256 maxRedeemRatio_, uint256 minRedeemDuration_, uint256 mediumRedeemDuration_, uint256 maxRedeemDuration_) external onlyOwner {\n        require(minRedeemRatio_ <= mediumRedeemRatio_ && mediumRedeemRatio_ <= maxRedeemRatio_, \"updateRedeemSettings: wrong ratio values\");\n        require(minRedeemDuration_ < mediumRedeemDuration_ && mediumRedeemDuration_ < maxRedeemDuration_, \"updateRedeemSettings: wrong duration values\");\n        // should never exceed 100%\n        require(maxRedeemRatio_ <= MAX_FIXED_RATIO, \"updateRedeemSettings: wrong ratio values\");\n\n        minRedeemRatio = minRedeemRatio_;\n        mediumRedeemRatio = mediumRedeemRatio_;\n        maxRedeemRatio = maxRedeemRatio_;\n        minRedeemDuration = minRedeemDuration_;\n        mediumRedeemDuration = mediumRedeemDuration_;\n        maxRedeemDuration = maxRedeemDuration_;\n\n        emit UpdateRedeemSettings(minRedeemRatio_, mediumRedeemRatio_, maxRedeemRatio_, minRedeemDuration_, mediumRedeemDuration_, maxRedeemDuration_);\n    }\n\n\n    /*****************************************************************/\n    /******************  EXTERNAL PUBLIC FUNCTIONS  ******************/\n    /*****************************************************************/\n\n    /**\n    * @dev Convert caller's \"amount\" of MOZ to xMOZ\n    */\n    function convert(uint256 amount) external  {\n        _convert(amount, msg.sender);\n    }\n\n    /**\n    * @dev Initiates redeem process (xMOZ to MOZ)\n    *\n    */\n    function redeem(uint256 xMozAmount, uint256 duration) external  {\n        require(xMozAmount > 0, \"redeem: xMozAmount cannot be zero\");\n        require(duration >= minRedeemDuration, \"redeem: Invalid duration\");\n        uint256 mozAmount = getMozByVestingDuration(xMozAmount, duration);\n        xMozToken.burn(xMozAmount, msg.sender);\n        uint256 redeemingAmount = xMozRedeemingBalances[msg.sender];\n        // get corresponding MOZ amount\n        if (mozAmount > 0) {\n             emit Redeem(msg.sender, xMozAmount, mozAmount, duration);\n            // add to total\n            xMozRedeemingBalances[msg.sender] = redeemingAmount + xMozAmount;\n            // add redeeming entry\n            userRedeems[msg.sender].push(RedeemInfo(mozAmount, xMozAmount, _currentBlockTimestamp() + duration));\n        }\n    }\n\n    /**\n    * @dev Finalizes redeem process when vesting duration has been reached\n    *\n    * Can only be called by the redeem entry owner\n    */\n    function finalizeRedeem(uint256 redeemIndex) external  validateRedeem(msg.sender, redeemIndex) {\n        uint256 redeemingAmount = xMozRedeemingBalances[msg.sender];\n        RedeemInfo storage _redeem = userRedeems[msg.sender][redeemIndex];\n        require(_currentBlockTimestamp() >= _redeem.endTime, \"finalizeRedeem: vesting duration has not ended yet\");\n\n        // remove from SBT total\n        xMozRedeemingBalances[msg.sender] = redeemingAmount - _redeem.xMozAmount;\n        _finalizeRedeem(msg.sender, _redeem.xMozAmount, _redeem.mozAmount);\n        // remove redeem entry\n        _deleteRedeemEntry(redeemIndex);\n    }\n\n    \n    /**\n    * @dev Cancels an ongoing redeem entry\n    *\n    * Can only be called by its owner\n    */\n    function cancelRedeem(uint256 redeemIndex) external  validateRedeem(msg.sender, redeemIndex) {\n        uint256 redeemingAmount = xMozRedeemingBalances[msg.sender];\n        RedeemInfo storage _redeem = userRedeems[msg.sender][redeemIndex];\n\n        // make redeeming xMOZ available again\n        xMozRedeemingBalances[msg.sender] = redeemingAmount - _redeem.xMozAmount;\n        xMozToken.mint(_redeem.xMozAmount, msg.sender);\n\n        emit CancelRedeem(msg.sender, _redeem.xMozAmount);\n\n        // remove redeem entry\n        _deleteRedeemEntry(redeemIndex);\n    }\n\n    /********************************************************/\n    /****************** INTERNAL FUNCTIONS ******************/\n    /********************************************************/\n\n    /**\n    * @dev Convert caller's \"amount\" of MOZ into xMOZ to \"to\"\n    */\n    function _convert(uint256 amount, address to) internal {\n        require(amount != 0, \"convert: amount cannot be null\");\n\n        mozaicToken.burn(amount, msg.sender);\n        // mint new xMOZ\n        xMozToken.mint(amount, to);\n\n        emit Convert(msg.sender, to, amount);\n    }\n\n    /**\n    * @dev Finalizes the redeeming process for \"userAddress\" by transferring him \"mozAmount\" and removing \"xMozAmount\" from supply\n    *\n    * Any vesting check should be ran before calling this\n    * MOZ excess is automatically burnt\n    */\n    function _finalizeRedeem(address userAddress, uint256 xMozAmount, uint256 mozAmount) internal {\n        // sends due MOZ tokens \n        uint256 mozExcess = xMozAmount - mozAmount;\n        // sends due Moz tokens\n        mozaicToken.mint(mozAmount, userAddress);\n        // burns Moz excess if any\n        if(mozExcess > 0) {\n            mozaicToken.mint(mozExcess, daoTreasury);\n        }\n        emit FinalizeRedeem(userAddress, xMozAmount, mozAmount);\n    }\n\n\n    function _deleteRedeemEntry(uint256 index) internal {\n        userRedeems[msg.sender][index] = userRedeems[msg.sender][userRedeems[msg.sender].length - 1];\n        userRedeems[msg.sender].pop();\n    }\n\n    /**\n    * @dev Utility function to get the current block timestamp\n    */\n    function _currentBlockTimestamp() internal view virtual returns (uint256) {\n        /* solhint-disable not-rely-on-time */\n        return block.timestamp;\n    }\n}"
    },
    "contracts/tokens/MozToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { OFT } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IMozToken } from \"../interfaces/tokens/IMozToken.sol\";\n\ncontract MozToken is IMozToken, OFT {\n\tusing SafeERC20 for IERC20;\n    address public mozStaking;\n\n    /***********************************************/\n\t/****************** CONSTRUCTOR ****************/\n\t/***********************************************/\n    /**\n     * @dev Constructor for the MozToken contract\n     * @param _lzEndpoint: address of the LayerZero endpoint\n     * @param _mozStaking: address of the MozStaking contract\n     * @custom:security-contact mailto:security@mozaic.finance\n     */\n    constructor(address _lzEndpoint, address _mozStaking)\n     OFT(\"Mozaic Token\", \"MOZ\", _lzEndpoint, msg.sender) Ownable(msg.sender) {\n        require(_mozStaking != address(0x0), \"Invalid address\");\n        mozStaking = _mozStaking;\n    }\n\n    /***********************************************/\n\t/****************** MODIFIERS ******************/\n\t/***********************************************/\n\n    /**\n     * @dev Modifier to check if the caller is the staking contract\n     */\n    modifier onlyStakingContract() {\n        require(msg.sender == mozStaking, \"Invalid caller\");\n        _;\n    }\n\n\n    /***********************************************/\n    /************** StakingFunctions ***************/\n    /***********************************************/\n\n    function burn(uint256 amount, address from) external onlyStakingContract {\n        _burn(from, amount);\n    }\n\n    function mint(uint256 _amount, address _to) external onlyStakingContract {\n        _mint(_to, _amount);\n    }\n\n    /***********************************************/\n    /***************** Recieve function ************/\n    /***********************************************/\n    receive() external payable {}\n\n    function withdrawStuckEth(address toAddr) external onlyOwner {\n        (bool success, ) = toAddr.call{\n            value: address(this).balance\n        } (\"\");\n        require(success);\n    }\n\n    function withdrawStuckToken(address token,address _to) external onlyOwner {\n        require(_to != address(0), \"Zero address\");\n        uint256 _contractMozBalance = balanceOf(address(this));\n        uint256 _contractTokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(address(this)).safeTransfer(_to, _contractMozBalance);\n        IERC20(token).safeTransfer(_to, _contractTokenBalance);\n    }\n}"
    },
    "contracts/tokens/MozTokenAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { OFTAdapter } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTAdapter.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MozTokenAdapter: Although the original Moz Token implementaion uses OFTV2 standard, due to a minor issue, it can't properly handle omnichain Token transfers. This adapter is created to fix the issue.\n * @notice There can only be one OFT Adapter used in an OFT deployment. Multiple OFT Adapters break omnichain unified liquidity by effectively creating token pools.\n */\n\ncontract MozTokenAdapter is OFTAdapter {\n    /**\n     * @custom:security-contact mailto:security@mozaic.finance\n     */\n    constructor(\n        address _token,\n        address _layerZeroEndpoint\n    ) OFTAdapter(_token, _layerZeroEndpoint, msg.sender) Ownable(msg.sender) {}\n}\n"
    },
    "contracts/tokens/XMOZToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { IXMozToken } from \"../interfaces/tokens/IXMozToken.sol\";\n\ncontract XMozToken is IXMozToken, ERC20, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    address public mozStaking;\n    EnumerableSet.AddressSet private _transferWhitelist; // addresses allowed to send/receive xMOZ\n\n    /***********************************************/\n    /****************** CONSTRUCTOR ****************/\n    /***********************************************/\n\n    /**\n     * @custom:security-contact mailto:security@mozaic.finance\n     */\n\n    constructor(\n        address _mozStaking\n    ) ERC20(\"Mozaic escrowed token\", \"xMOZ\") Ownable(msg.sender) {\n        require(_mozStaking != address(0x0), \"Invalid addr\");\n        _transferWhitelist.add(address(this));\n        mozStaking = _mozStaking;\n    }\n\n    /***********************************************/\n    /****************** MODIFIERS ******************/\n    /***********************************************/\n\n    modifier onlyStakingContract() {\n        require(msg.sender == mozStaking, \"Invalid caller\");\n        _;\n    }\n\n    /***********************************************/\n    /****************** EVENTS *********************/\n    /***********************************************/\n\n    event SetTransferWhitelist(address account, bool add);\n\n    /***********************************************/\n    /****************** FUNCTIONS ******************/\n    /***********************************************/\n\n    /**\n    * @dev returns length of transferWhitelist array\n    */\n    function transferWhitelistLength() external view returns (uint256) {\n        return _transferWhitelist.length();\n    }\n\n    /**\n    * @dev returns transferWhitelist array item's address for \"index\"\n    */\n    function transferWhitelist(uint256 index) external view returns (address) {\n        return _transferWhitelist.at(index);\n    }\n\n    /**\n    * @dev returns if \"account\" is allowed to send/receive xMOZ\n    */\n    function isTransferWhitelisted(address account) public view returns (bool) {\n        return _transferWhitelist.contains(account);\n    }\n\n    /**\n    * @dev Adds or removes addresses from the transferWhitelist\n    */\n    function updateTransferWhitelist(address account, bool add) external onlyOwner {\n        require(account != address(this), \"updateTransferWhitelist: Cannot remove xMoz from whitelist\");\n\n        if(add) _transferWhitelist.add(account);\n        else _transferWhitelist.remove(account);\n\n        emit SetTransferWhitelist(account, add);\n    }\n\n    function mint(uint256 _amount, address _to) external onlyStakingContract {\n        _mint(_to, _amount);\n    }\n\n    function burn(uint256 _amount, address _from) external onlyStakingContract {\n        _burn(_from, _amount);\n    }\n\n    /***********************************************/\n    /*************** Hook Overrides ****************/\n    /***********************************************/\n    \n    /**\n    * @dev Hook override to forbid transfers except from whitelisted addresses and minting\n    */\n    function _update(address from, address to, uint256 value) internal override {\n        require(from == address(0) || to == address(0) && msg.sender == mozStaking || from == owner() || isTransferWhitelisted(from), \"transfer: not allowed\");\n        super._update(from, to, value);\n    }\n\n\n\n}\n\n\n"
    },
    "contracts/vaults/theseus/GmxCallback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/gmx/IDepositCallbackReceiver.sol\";\nimport \"../../interfaces/gmx/IWithdrawalCallbackReceiver.sol\";\nimport \"../../interfaces/gmx/IOrderCallbackReceiver.sol\";\nimport \"../../interfaces/gmx/IPlugin.sol\";\nimport \"../../interfaces/gmx/ICallbackContract.sol\";\nimport \"../../interfaces/vaults/IVault.sol\";\nimport \"../../interfaces/vaults/IVaultLocker.sol\";\n\n\n/**\n * @title GmxCallback\n * @dev Contract handling callbacks for deposit, withdrawal, and order execution/cancellation.\n */\ncontract GmxCallback is Ownable, IDepositCallbackReceiver, IWithdrawalCallbackReceiver, IOrderCallbackReceiver, ICallbackContract, IVaultLocker {\n    // Structure to hold the withdrawal information associated with a key\n    struct WithdrawalInfo {\n        uint256 lpAmount;\n        address receiver;\n    }\n\n    // Configuration struct for the contract\n    struct Config {\n        address vault;\n        address gmxPlugin;\n    }\n\n    // Mapping to store withdrawal data for each key\n    mapping(bytes32 => WithdrawalInfo) public withdrawalData;\n\n    // Configuration state\n    Config public config;\n\n    // Arrays to store keys for deposit, withdrawal, and order operations\n    bytes32[] public depositKeys;\n    bytes32[] public withdrawalKeys;\n    bytes32[] public orderKeys;\n\n    // Handlers for deposit, withdrawal, and order operations\n    address public depositHandler;\n    address public withdrawalHandler;\n    address public orderHandler;\n\n    event SetConfig(address _vault, address _gmxPlugin);\n    event SetHandler(address _depositHandler, address _withdrawalHandler, address _orderHandler);\n    event AddKey(bytes32 _key, State stateOption);\n    event AddWithdrawalData(bytes32 _withdrawalKey, uint256 _lpAmount, address _receiver);\n    event RemoveKey(bytes32 _key, State _stateOption);\n    event AfterDepositExecution(bytes32 _key);\n    event AfterDepositCancellation(bytes32 _key);\n    event AfterWithdrawalExecution(bytes32 _key);\n    event AfterWithdrawalCancellation(bytes32 _key);\n    event AfterOrderExecution(bytes32 _key);\n    event AfterOrderCancellation(bytes32 _key);\n    event AfterOrderFrozen(bytes32 _key);\n\n    // Modifier to restrict access to the GMX plugin only\n    modifier onlyGmxPlugin() {\n        require(msg.sender == config.gmxPlugin, \"Invalid caller\");\n        _;\n    }\n\n    // Modifier to restrict access to specific handlers (deposit, withdrawal, order)\n    modifier onlyHandler(State stateOption) {\n        address handler;\n        if (stateOption == State.Deposit) {\n            handler = depositHandler;\n        } else if (stateOption == State.Withdrawal) {\n            handler = withdrawalHandler;\n        } else if (stateOption == State.Order) {\n            handler = orderHandler;\n        } else {\n            revert(\"Invalid state\");\n        }\n        require(msg.sender == handler, \"Invalid caller\");\n        _;\n    }\n\n    /**\n     * @dev Constructor to initialize the contract with the vault and GMX plugin addresses.\n     * @param _vault Address of the vault.\n     * @param _gmxPlugin Address of the GMX plugin.\n     */\n    constructor(address _vault, address _gmxPlugin) Ownable(msg.sender) {\n        config = Config({\n            vault: _vault,\n            gmxPlugin: _gmxPlugin\n        });\n    }\n\n    /**\n     * @dev Updates the vault and GMX plugin addresses in the contract configuration.\n     * @param _vault New address of the vault.\n     * @param _gmxPlugin New address of the GMX plugin.\n     */\n    function setConfig(address _vault, address _gmxPlugin) external onlyOwner {\n        require(_vault != address(0) && _gmxPlugin != address(0), \"Invalid address\");\n\n        config = Config({\n            vault: _vault,\n            gmxPlugin: _gmxPlugin\n        });\n\n        emit SetConfig(_vault, _gmxPlugin);\n    }\n\n    /**\n     * @dev Updates the deposit, withdrawal, and order handlers in the contract.\n     * @param _depositHandler Address of the deposit handler.\n     * @param _withdrawalHandler Address of the withdrawal handler.\n     * @param _orderHandler Address of the order handler.\n     */\n    function setHandler(address _depositHandler, address _withdrawalHandler, address _orderHandler) external onlyOwner {\n        require(_depositHandler != address(0) && _withdrawalHandler != address(0) && _orderHandler != address(0), \"Invalid address\");\n\n        depositHandler = _depositHandler;\n        withdrawalHandler = _withdrawalHandler;\n        orderHandler = _orderHandler;\n\n        emit SetHandler(_depositHandler, _withdrawalHandler, _orderHandler);\n    }\n\n    /**\n     * @dev Adds a key to the corresponding array based on the state option (Deposit, Withdrawal, Order).\n     * @param _key The key to be added.\n     * @param _stateOption The state option (Deposit, Withdrawal, Order).\n     */\n    function addKey(bytes32 _key, State _stateOption) external onlyGmxPlugin {\n        if (_stateOption == State.Deposit) {\n            depositKeys.push(_key);\n        } else if (_stateOption == State.Withdrawal) {\n            withdrawalKeys.push(_key);\n        } else if (_stateOption == State.Order) {\n            orderKeys.push(_key);\n        } else {\n            revert(\"Invalid state\");\n        }\n\n        emit AddKey(_key, _stateOption);\n    }\n\n    /**\n     * @dev Adds withdrawal data for a specific key.\n     * @param _withdrawalKey The key associated with the withdrawal data.\n     * @param _lpAmount The LP amount to be withdrawn.\n     * @param _receiver The address to receive the LP tokens.\n     */\n    function addWithdrawalData(bytes32 _withdrawalKey, uint256 _lpAmount, address _receiver) external onlyGmxPlugin {\n        bool isExist = false;\n        for (uint256 i = 0; i < withdrawalKeys.length; ++i) {\n            if (withdrawalKeys[i] == _withdrawalKey) {\n                isExist = true;\n            }\n        }\n        require(isExist, \"Invalid withdrawal key\");\n        withdrawalData[_withdrawalKey] = WithdrawalInfo({\n            lpAmount: _lpAmount,\n            receiver: _receiver\n        });\n\n        emit AddWithdrawalData(_withdrawalKey, _lpAmount, _receiver);\n    }\n\n    /**\n     * @dev Retrieves an array of keys based on the state option (Deposit, Withdrawal, Order).\n     * @param stateOption The state option (Deposit, Withdrawal, Order).\n     * @return An array of keys associated with the specified state option.\n     */\n    function getKeys(State stateOption) public view returns (bytes32[] memory) {\n        if (stateOption == State.Deposit) {\n            return depositKeys;\n        } else if (stateOption == State.Withdrawal) {\n            return withdrawalKeys;\n        } else if (stateOption == State.Order) {\n            return orderKeys;\n        } else {\n            revert(\"Invalid state\");\n        }\n    }\n\n    function getWithdrawalDatas() public view returns (WithdrawalInfo[] memory) {\n        uint256 length = withdrawalKeys.length;\n        WithdrawalInfo[] memory result = new WithdrawalInfo[](length);\n\n        for(uint256 i = 0; i < length; i++) {\n            result[i] = withdrawalData[withdrawalKeys[i]];\n        }\n        return result;\n    }\n\n    /**\n     * @dev Removes a key from the corresponding array based on the state option (Deposit, Withdrawal, Order).\n     * @param _key The key to be removed.\n     * @param _stateOption The state option (Deposit, Withdrawal, Order).\n     */\n    function removeKey(bytes32 _key, State _stateOption) internal {\n        bytes32[] storage targetArray;\n\n        if (_stateOption == State.Deposit) {\n            targetArray = depositKeys;\n        } else if (_stateOption == State.Withdrawal) {\n            targetArray = withdrawalKeys;\n        } else if (_stateOption == State.Order) {\n            targetArray = orderKeys;\n        } else {\n            revert(\"Invalid state\");\n        }\n\n        uint256 length = targetArray.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (targetArray[i] == _key) {\n                // Found the element, now remove it\n                if (i < length - 1) {\n                    // Move the last element to the position of the element to be removed\n                    targetArray[i] = targetArray[length - 1];\n                }\n                // Remove the last element (which is now a duplicate or the original element)\n                targetArray.pop();\n\n                // You may choose to break here if you want to remove only the first occurrence\n                break;\n            }\n        }\n\n        emit RemoveKey(_key, _stateOption);\n    }\n\n    /**\n     * @dev Checks whether the contract is locked (i.e., no active deposit, withdrawal, or order).\n     * @return True if the contract is locked, false otherwise.\n     */\n    function getLockerStatus() public view returns (bool) {\n        return depositKeys.length == 0 && withdrawalKeys.length == 0 && orderKeys.length == 0;\n    }\n\n    /**\n     * @dev Handles actions after a deposit execution.\n     * @param key The key associated with the deposit.\n     * @param deposit The deposit details.\n     * @param eventData Additional event data.\n     */\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external onlyHandler(State.Deposit) {\n        removeKey(key, State.Deposit);\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n        \n        emit AfterDepositExecution(key);\n    }\n\n    /**\n     * @dev Handles actions after a deposit cancellation.\n     * @param key The key associated with the deposit.\n     * @param deposit The deposit details.\n     * @param eventData Additional event data.\n     */\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external onlyHandler(State.Deposit) {\n        removeKey(key, State.Deposit);\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n        \n        emit AfterDepositCancellation(key);\n    }\n\n    /**\n     * @dev Handles actions after a withdrawal execution.\n     * @param key The key associated with the withdrawal.\n     * @param withdrawal The withdrawal details.\n     * @param eventData Additional event data.\n     */\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external onlyHandler(State.Withdrawal) {\n        removeKey(key, State.Withdrawal);\n        WithdrawalInfo memory info = withdrawalData[key];\n        if (info.lpAmount != 0) {\n            IVault(config.vault).burnLP(info.lpAmount);\n        }\n        delete withdrawalData[key];\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n        \n        emit AfterWithdrawalExecution(key);\n    }\n\n    /**\n     * @dev Handles actions after a withdrawal cancellation.\n     * @param key The key associated with the withdrawal.\n     * @param withdrawal The withdrawal details.\n     * @param eventData Additional event data.\n     */\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external onlyHandler(State.Withdrawal) {\n        removeKey(key, State.Withdrawal);\n        WithdrawalInfo memory info = withdrawalData[key];\n        if (info.lpAmount != 0 && info.receiver != address(0) && info.receiver != config.gmxPlugin) {\n            IVault(config.vault).transferLP(info.receiver, info.lpAmount);\n        }\n        delete withdrawalData[key];\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n\n        emit AfterWithdrawalCancellation(key);\n    }\n\n    /**\n     * @dev Handles actions after an order execution.\n     * @param key The key associated with the order.\n     * @param order The order details.\n     * @param eventData Additional event data.\n     */\n    function afterOrderExecution(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external onlyHandler(State.Order) {\n        removeKey(key, State.Order);\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n\n        emit AfterOrderExecution(key);\n    }\n\n    /**\n     * @dev Handles actions after an order cancellation.\n     * @param key The key associated with the order.\n     * @param order The order details.\n     * @param eventData Additional event data.\n     */\n    function afterOrderCancellation(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external onlyHandler(State.Order) {\n        removeKey(key, State.Order);\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n\n        emit AfterOrderCancellation(key);\n    }\n\n    /**\n     * @dev Handles actions after an order is frozen.\n     * @param key The key associated with the order.\n     * @param order The order details.\n     * @param eventData Additional event data.\n     */\n    function afterOrderFrozen(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external onlyHandler(State.Order) {\n        IPlugin(config.gmxPlugin).transferAllTokensToVault();\n\n        emit AfterOrderFrozen(key);\n    }\n}"
    },
    "contracts/vaults/theseus/GmxPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n// Libraries\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"../../interfaces/gmx/IExchangeRouter.sol\";\nimport \"../../interfaces/gmx/IDataStore.sol\";\nimport \"../../interfaces/gmx/IReader.sol\";\nimport \"../../interfaces/gmx/IMarket.sol\";\nimport \"../../interfaces/gmx/ICallbackContract.sol\";\n\nimport \"../TokenPriceConsumer.sol\";\n\ncontract GmxPlugin is Ownable, IPlugin, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /* ========== CONSTANTS ========== */\n    // Constant defining the decimal precision for asset values.\n    uint256 public constant ASSET_DECIMALS = 36;\n\n    // Constant defining the decimal precision for market token prices.\n    uint256 public constant MARKET_TOKEN_PRICE_DECIMALS = 30;\n\n    /* ========== STRUCTS ========== */\n    // Struct defining configuration parameters for the router.\n    struct RouterConfig {\n        address exchangeRouter;   // Address of the exchange router contract.\n        address router;           // Address of the router contract.\n        address depositVault;     // Address of the deposit vault contract.\n        address withdrawVault;    // Address of the withdraw vault contract.\n        address orderVault;       // Address of the order vault contract.\n        address reader;           // Address of the reader contract.\n    }\n\n    // Struct defining configuration parameters for a pool.\n    struct PoolConfig {\n        uint8 poolId;           // Unique identifier for the pool.\n        address indexToken;       // Address of the index token associated with the pool.\n        address longToken;        // Address of the long token associated with the pool.\n        address shortToken;       // Address of the short token associated with the pool.\n        address marketToken;      // Address of the market token associated with the pool.\n    }\n\n    // Struct defining parameters related to Gmx (Governance Mining) functionality.\n    struct GmxParams {\n        address uiFeeReceiver;    // Address to receive UI fees.\n        address callbackContract;  // Address of the callback contract for Gmx interactions.\n        uint256 callbackGasLimit; // Gas limit for Gmx callback functions.\n        uint256 executionFee;     // Execution fee for Gmx interactions.\n        bool shouldUnwrapNativeToken; // Flag indicating whether native tokens should be unwrapped during Gmx interactions.\n        bytes32 pnlFactorType;     // PNL factor type to get the market token price\n    }\n\n    struct PoolValue {\n        uint8 poolId;\n        uint256 poolValue;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n    // Address of the local vault associated with the smart contract.\n    address public localVault;\n\n    // Address of the treasury where funds are managed.\n    address payable public treasury;\n\n    // Configuration parameters for the router, specifying key contracts and components.\n    RouterConfig public routerConfig;\n\n    // Parameters related to Governance Mining (Gmx) functionality.\n    GmxParams public gmxParams;\n\n    // Array storing configuration details for different pools.\n    PoolConfig[] public pools;\n\n    // Mapping to track the existence of pools based on their unique identifiers.\n    mapping(uint8 => bool) public poolExistsMap;\n\n    // Array containing unique tokens associated with the contract.\n    address[] public uniqueTokens;\n\n    // Address of the token price consumer contract used for obtaining token prices.\n    address public tokenPriceConsumer;\n\n    address[] public rewardTokens;\n    \n    mapping(address => uint8) public tokenDecimalList;\n\n    /* ========== EVENTS ========== */\n    event SetMaster(address master);\n    event SetTreasury(address payable treasury);\n    event SetRouterConfig(address _exchangeRouter, address _router, address _depositVault, address _withdrawVault, address _orderVault, address _reader);\n    event SetGmxParams(address _uiFeeReceiver, address _callbackContract, uint256 _callbackGasLimit, uint256 _executionFee, bool _shouldUnwrapNativeToken, bytes32 _pnlFactorType);\n    event SetTokenPriceConsumer(address _tokenPriceConsumer);\n    event SetTokenDecimals(address _token, uint8 _decimals);\n    event SetRewardTokens(address[] _rewardTokens);\n    event PoolAdded(uint8 poolId);\n    event PoolRemoved(uint8 poolId);\n    event Execute(ActionType _actionType, bytes _payload);\n    event TransferAllTokensToVault();\n    event CancelAction(uint8 _actionType, bytes32 _key);\n    /* ========== MODIFIERS ========== */\n\n    // Modifier allowing only the local vault to execute the function.\n    modifier onlyVault() {\n        require(msg.sender == localVault, \"Invalid caller\");\n        _;\n    }\n\n    // Modifier allowing only the local vault to execute the function.\n    modifier onlyCallback() {\n        require(msg.sender == gmxParams.callbackContract, \"Invalid caller\");\n        _;\n    }\n\n    /* ========== CONFIGURATION ========== */\n\n    // Constructor initializing the GMX contract with the address of the local vault.\n    constructor(address _localVault) Ownable(msg.sender) {\n        // Ensure the provided local vault address is valid.\n        require(_localVault != address(0), \"GMX: Invalid Address\");\n        // Set the localVault address.\n        localVault = _localVault;\n    }\n\n    // Function allowing the owner to set the treasury address.\n    function setTreasury(address payable _treasury) public onlyOwner {\n        // Ensure the provided treasury address is valid.\n        require(_treasury != address(0), \"Vault: Invalid address\");\n        // Set the treasury address.\n        treasury = _treasury;\n        // Emit an event signaling the treasury address update.\n        emit SetTreasury(_treasury);\n    }\n\n\n    // Function allowing the owner to set the router configuration parameters.\n    function setRouterConfig(\n        address _exchangeRouter,\n        address _router,\n        address _depositVault,\n        address _withdrawVault,\n        address _orderVault,\n        address _reader\n    ) external onlyOwner {\n        // Ensure all provided addresses are valid.\n        require(\n            _exchangeRouter != address(0) && \n            _router != address(0) && \n            _depositVault != address(0) && \n            _withdrawVault != address(0) && \n            _orderVault != address(0) && \n            _reader != address(0),\n            \"GMX: Invalid Address\"\n        );\n\n        // Set the router configuration with the provided addresses.\n        routerConfig = RouterConfig({\n            exchangeRouter: _exchangeRouter,\n            router: _router,\n            depositVault: _depositVault,\n            withdrawVault: _withdrawVault,\n            orderVault: _orderVault,\n            reader: _reader\n        });\n\n        emit SetRouterConfig(_exchangeRouter, _router, _depositVault, _withdrawVault, _orderVault, _reader);\n    }\n\n    // Function allowing the owner to set Governance Mining (Gmx) parameters.\n    function setGmxParams(\n        address _uiFeeReceiver,\n        address _callbackContract,\n        uint256 _callbackGasLimit,\n        uint256 _executionFee,\n        bool _shouldUnwrapNativeToken,\n        bytes32 _pnlFactorType\n    ) public onlyOwner {\n        // Set the Gmx parameters with the provided values.\n        gmxParams = GmxParams({\n            uiFeeReceiver: _uiFeeReceiver,\n            callbackContract: _callbackContract,\n            callbackGasLimit: _callbackGasLimit,\n            executionFee: _executionFee,\n            shouldUnwrapNativeToken: _shouldUnwrapNativeToken,\n            pnlFactorType: _pnlFactorType\n        });\n\n        emit SetGmxParams(_uiFeeReceiver, _callbackContract, _callbackGasLimit, _executionFee, _shouldUnwrapNativeToken, _pnlFactorType);\n    }\n\n    function setTokenDecimals(address _token, uint8 _decimals) public onlyOwner {\n        tokenDecimalList[_token] = _decimals;\n\n        emit SetTokenDecimals(_token, _decimals);\n    }\n\n\n    function setTokenDecimalsBatch(address[] calldata _tokens, uint8[] calldata _newDecimals) external onlyOwner {\n        require(_tokens.length == _newDecimals.length, \"Arrays must have the same length\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            setTokenDecimals(_tokens[i], _newDecimals[i]);\n        }\n    }\n\n    // Function allowing the owner to set the token price consumer contract address.\n    function setTokenPriceConsumer(address _tokenPriceConsumer) public onlyOwner {\n        // Ensure the provided token price consumer address is valid.\n        require(_tokenPriceConsumer != address(0), \"GMX: Invalid Address\");\n        \n        // Set the token price consumer contract address.\n        tokenPriceConsumer = _tokenPriceConsumer;\n\n        emit SetTokenPriceConsumer(_tokenPriceConsumer);\n    }\n\n    function setRewardTokens(address[] memory _rewardTokens) public onlyOwner {\n        rewardTokens = _rewardTokens;\n\n        emit SetRewardTokens(_rewardTokens);\n    }\n\n    // Function allowing the owner to add a new pool with specified configuration.\n    function addPool(\n        uint8 _poolId,\n        address _indexToken,\n        address _longToken,\n        address _shortToken,\n        address _marketToken\n    ) external onlyOwner {\n        // Ensure the pool with the given poolId does not already exist.\n        require(_poolId != 0, \"GMX: Invalid Pool Id\");\n        require(!poolExistsMap[_poolId], \"GMX: Pool with this poolId already exists\");\n\n        // Create a new pool configuration and add it to the array.\n        PoolConfig memory newPool = PoolConfig(_poolId, _indexToken, _longToken, _shortToken, _marketToken);\n        pools.push(newPool);\n\n        // Mark the pool as existing.\n        poolExistsMap[_poolId] = true;\n\n        // Add unique tokens to the list if not already present.\n        if (!isTokenAdded(_longToken)) {\n            uniqueTokens.push(_longToken);\n        }\n\n        if (!isTokenAdded(_shortToken)) {\n            uniqueTokens.push(_shortToken);\n        }\n\n        // Emit an event indicating the addition of a new pool.\n        emit PoolAdded(_poolId);\n    }\n\n    // Function allowing the owner to remove an existing pool.\n    function removePool(uint8 _poolId) external onlyOwner {\n        // Ensure the pool with the given poolId exists.\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n\n        // Find the index of the pool in the array.\n        uint256 indexToRemove = getPoolIndexById(_poolId);\n\n        // Swap the pool to remove with the last pool in the array.\n        // This avoids leaving gaps in the array.\n        uint256 lastIndex = pools.length - 1;\n        if (indexToRemove != lastIndex) {\n            pools[indexToRemove] = pools[lastIndex];\n        }\n\n        // Remove the last pool (which now contains the removed pool's data).\n        pools.pop();\n\n        // Mark the pool as no longer existing.\n        delete poolExistsMap[_poolId];\n\n        // Update the list of unique tokens.\n        updateUniqueTokens();\n\n        // Emit an event indicating the removal of an existing pool.\n        emit PoolRemoved(_poolId);\n    }\n\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n    // Function allowing the vault to execute different actions based on the specified action type.\n    function execute(ActionType _actionType, bytes calldata _payload) external payable onlyVault nonReentrant {\n        // Determine the action type and execute the corresponding logic.\n        if (_actionType == ActionType.Stake) {\n            // Execute stake action.\n            stake(_payload);\n        } else if (_actionType == ActionType.Unstake) {\n            // Execute unstake a ction.\n            unstake(_payload);\n        } else if (_actionType == ActionType.SwapTokens) {\n            // Execute token swap action (create order).\n            createOrder(_payload);\n        } else if (_actionType == ActionType.CancelAction) {\n            // Execute cancel action.\n            cancelAction(_payload);\n        } else if (_actionType == ActionType.ClaimRewards) {\n            claimRewards();\n        }\n\n        emit Execute(_actionType, _payload);\n    }\n\n    // Transfers all ERC-20 tokens held by this contract to a designated vault.\n    function transferAllTokensToVault() public onlyCallback {\n        // Iterate through all unique tokens stored in the contract\n        for (uint256 i = 0; i < uniqueTokens.length; ++i) {\n            // Get the balance of the current token held by this contract\n            uint256 tokenBalance = IERC20(uniqueTokens[i]).balanceOf(address(this));\n\n            // Check if the token balance is greater than zero\n            if (tokenBalance > 0) {\n                // Safely transfer the entire balance of the current token to the designated vault\n                IERC20(uniqueTokens[i]).safeTransfer(localVault, tokenBalance);\n            }\n        }\n\n        emit TransferAllTokensToVault();\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    // Function to calculate the total liquidity (totalAsset) of the vault, considering balances in unique tokens and pools.\n    function getTotalLiquidity() public view returns (uint256 totalAsset) {\n        // Iterate over uniqueTokens and calculate totalAsset based on token balances.\n        for (uint256 i = 0; i < uniqueTokens.length; ++i) {\n            address tokenAddress = uniqueTokens[i];\n            uint256 tokenBalance = IERC20(tokenAddress).balanceOf(address(this));\n            totalAsset += calculateTokenValueInUsd(tokenAddress, tokenBalance);\n        }\n\n        // Iterate over pools and calculate totalAsset based on market token balances and prices.\n        for (uint256 i = 0; i < pools.length; ++i) {\n            address marketTokenAddress = pools[i].marketToken;\n            uint256 marketTokenBalance = IERC20(marketTokenAddress).balanceOf(address(this));\n            int256 marketTokenPrice = getPoolTokenPrice(pools[i].poolId, true);\n            if (marketTokenPrice <= 0) continue;\n            uint256 amount = marketTokenBalance * uint256(marketTokenPrice);\n\n            // Use IERC20Metadata only once to get decimals.\n            uint256 decimals = IERC20Metadata(marketTokenAddress).decimals() + MARKET_TOKEN_PRICE_DECIMALS;\n\n            uint256 adjustedAmount = convertDecimals(amount, decimals, ASSET_DECIMALS);\n\n            // Accumulate adjustedAmount to totalAsset.\n            totalAsset += adjustedAmount;\n        }\n    }\n\n    // Public view function that retrieves an array of PoolValues representing the values of each pool.\n    // Each PoolValue includes the poolId and the adjusted market value of the pool.\n    // The adjusted market value is calculated based on the balance and price of the market token in each pool.\n    function getPoolValues() public view returns (PoolValue[] memory){\n        // Initialize a dynamic array to store PoolValues for each pool.\n        PoolValue[] memory poolValues = new PoolValue[](pools.length);\n\n        // Iterate through each pool to calculate and store the adjusted market value.\n        for (uint256 i = 0; i < pools.length; ++i) {\n            address marketTokenAddress = pools[i].marketToken;\n            uint256 marketTokenBalance = IERC20(marketTokenAddress).balanceOf(address(this));\n\n            // Get the current price of the market token in the pool.\n            int256 marketTokenPrice = getPoolTokenPrice(pools[i].poolId, true);\n\n            // Calculate the adjusted amount based on the market token balance and price.\n            uint256 adjustedAmount;\n            if (marketTokenPrice > 0) {\n                uint256 amount = marketTokenBalance * uint256(marketTokenPrice);\n\n                // Use IERC20Metadata to get the decimals of the market token.\n                uint256 decimals = IERC20Metadata(marketTokenAddress).decimals() + MARKET_TOKEN_PRICE_DECIMALS;\n\n                // Convert the amount to the desired decimal precision.\n                adjustedAmount = convertDecimals(amount, decimals, ASSET_DECIMALS);\n            }\n\n            // Create a PoolValue struct with poolId and adjusted market value.\n            PoolValue memory data = PoolValue({\n                poolId: pools[i].poolId,\n                poolValue: adjustedAmount\n            });\n\n            // Assign the PoolValue to the array at the correct index.\n            poolValues[i] = data;\n        }\n\n        // Return the array of PoolValues representing the values of each pool.\n        return poolValues;\n    }\n\n    // Function to calculate the USD value of a given token amount based on its price and decimals.\n    function calculateTokenValueInUsd(address _tokenAddress, uint256 _tokenAmount) public view returns (uint256) {\n        uint256 tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Get the token price from the TokenPriceConsumer.\n        uint256 tokenPrice = TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        return convertDecimals(_tokenAmount * tokenPrice, tokenDecimals + priceConsumerDecimals, ASSET_DECIMALS);\n    }\n\n\n    // Function to retrieve the total number of pools in the vault.\n    function getPoolNumber() public view returns(uint256) {\n        return pools.length;\n    }\n\n    // Function to retrieve the array of unique tokens stored in the vault.\n    function getUniqueTokens() public view returns (address[] memory) {\n        return uniqueTokens;\n    }\n\n    // Function to retrieve the length of the array of unique tokens.\n    function getUniqueTokenLength() public view returns(uint256) {\n        return uniqueTokens.length;\n    }\n\n    // Function to retrieve the array of pool configurations stored in the vault.\n    function getPools() public view returns(PoolConfig[] memory) {\n        return pools;\n    }\n\n    // Function to retrieve the length of the array of pool configurations.\n    function getPoolLength() public view returns (uint256) {\n        return pools.length;\n    }\n\n    // Function to check if a token is present in the uniqueTokens array.\n    function isTokenAdded(address _token) public view returns(bool) {\n        for(uint256 i; i < uniqueTokens.length; ++i) {\n            if(uniqueTokens[i] == _token) return true;\n        }\n        return false;\n    }\n\n    // Internal function to check if a token exists in the longToken or shortToken of any pool configurations.\n    function tokenExistsInList(address _token) internal view returns (bool) {\n        for (uint256 i = 0; i < pools.length; i++) {\n            if (pools[i].longToken == _token || pools[i].shortToken == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Internal function to get the index of a pool in the array by poolId\n    function getPoolIndexById(uint8 _poolId) public view returns (uint256 poolIndex) {\n        for (uint256 index = 0; index < pools.length; index++) {\n            if (pools[index].poolId == _poolId) {\n                // Pool found, return its index\n                poolIndex = index;\n                return poolIndex;\n            }\n        }\n        // If the pool is not found, revert with an error message\n        revert(\"GMX: Pool not found\");\n    }\n\n    // Updates the 'uniqueTokens' array by removing tokens that no longer exist.\n    function updateUniqueTokens() internal {\n        for (uint256 i = uniqueTokens.length; i > 0; i--) {\n            if (!tokenExistsInList(uniqueTokens[i - 1])) {\n                // Remove the token from uniqueTokens\n                uniqueTokens[i - 1] = uniqueTokens[uniqueTokens.length - 1];\n                uniqueTokens.pop();\n            }\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    // Internal function to stake tokens into a specified pool.\n    // The payload includes the pool ID, an array of two tokens (long and short), and corresponding amounts.\n    // Validates the existence of the pool, array lengths, correct pool tokens, and non-zero token amounts.\n    // Transfers tokens from localVault to the contract and executes buyGMToken function.\n    function stake(bytes calldata _payload) internal {\n        // Decode payload\n        (uint8 _poolId, address[] memory _tokens, uint256[] memory _amounts, bytes memory payload) = abi.decode(_payload, (uint8, address[], uint256[], bytes));\n        (uint256 minGMAmount) = abi.decode(payload, (uint256));\n\n        // Validate pool existence\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n\n        // Validate array lengths\n        require(_tokens.length == 2 && _amounts.length == 2, \"GMX: Array length must be 2\");\n\n        // Get pool index and pool configuration\n        uint256 index = getPoolIndexById(_poolId);\n        PoolConfig memory pool = pools[index];\n\n        // Validate tokens\n        require(pool.longToken == _tokens[0] && pool.shortToken == _tokens[1], \"GMX: Invalid Pool tokens\");\n\n        // Validate token amounts\n        require(_amounts[0] != 0 || _amounts[1] != 0, \"GMX: Invalid token amount\");\n\n        // Transfer tokens from localVault to contract if amounts are positive\n        if (_amounts[0] > 0) {\n            IERC20(pool.longToken).safeTransferFrom(localVault, address(this), _amounts[0]);\n        }\n\n        if (_amounts[1] > 0) {\n            IERC20(pool.shortToken).safeTransferFrom(localVault, address(this), _amounts[1]);\n        }\n\n        // Execute buyGMToken function\n        buyGMToken(_poolId, _amounts[0], _amounts[1], minGMAmount);\n    }\n\n    // Internal function to unstake GM tokens from a specified pool.\n    // The payload includes the pool ID and the market amount to sell.\n    // Decodes the payload and performs the sell operation using sellGMToken function.\n    function unstake(bytes calldata _payload) internal {\n        // Decode payload\n        (uint8 poolId, uint256 marketAmount, uint256 lpAmount, address receiver, bytes memory data) = abi.decode(_payload, (uint8, uint256, uint256, address, bytes));\n        (uint256 minLongTokenAmount, uint256 minShortTokenAmount) = abi.decode(data, (uint256, uint256));\n\n        // Perform sell operation\n        sellGMToken(poolId, marketAmount, lpAmount, minLongTokenAmount, minShortTokenAmount, receiver);\n    }\n\n    // Internal function to create a GM token order using provided order parameters.\n    // The payload includes order parameters in the CreateOrderParams structure.\n    // Decodes the payload and executes createGMOrder function.\n    function createOrder(bytes calldata _payload) internal {\n        // Decode payload\n        IExchangeRouter.CreateOrderParams memory orderParams = abi.decode(_payload, (IExchangeRouter.CreateOrderParams));\n\n        // Execute createGMOrder function\n        createGMOrder(orderParams);\n    }\n\n    // This internal function is responsible for canceling different types of actions based on the provided payload.\n    // It decodes the payload to extract action type and key information, then calls corresponding cancellation functions.\n    // The supported action types are: 0 for canceling deposit, 1 for canceling withdrawal, and 2 for canceling an order.\n    function cancelAction(bytes calldata _payload) internal {\n        (uint8 _actionType, bytes32 _key) = abi.decode(_payload, (uint8, bytes32));\n        if(_actionType == 0) {\n            cancelDeposit(_key);    // Cancels a deposit with the specified key.\n        } else if(_actionType == 1) {\n            cancelWithdrawal(_key); // Cancels a withdrawal with the specified key.\n        } else if(_actionType == 2) {\n            cancelOrder(_key);      // Cancels an order with the specified key.\n        }\n\n        emit CancelAction(_actionType, _key); // Emits an event to log the canceled action type and key.\n    }\n\n    // This internal function is responsible for claiming rewards for each token in the rewardTokens array.\n    // It iterates through the rewardTokens, checks the balance of each token, and transfers the balance to a local vault.\n    // The localVault variable should be set appropriately before calling this function.\n    function claimRewards() internal {\n        for(uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 amount = IERC20(rewardTokens[i]).balanceOf(address(this));\n            if(amount > 0) {\n                // Safely transfers the reward amount to the specified localVault address.\n                IERC20(rewardTokens[i]).safeTransfer(localVault, amount);\n            }\n        }\n    }\n\n\n    /* ========== GMX FUNCTIONS ========== */\n    // Internal function to buy GM tokens in a specified pool.\n    // Handles the approval of token transfers, prepares swap paths, and executes multicall to deposit assets and create GM tokens.\n    function buyGMToken(uint8 _poolId, uint256 _longTokenAmount, uint256 _shortTokenAmount, uint256 _minGmAmount) internal {\n        // Retrieve pool configuration\n        PoolConfig memory pool = pools[getPoolIndexById(_poolId)];\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Prepare swap paths and other variables\n        address longToken = pool.longToken;\n        address shortToken = pool.shortToken;\n        address marketAddress = pool.marketToken;\n        address[] memory longTokenSwapPath;\n        address[] memory shortTokenSwapPath;\n        uint256 executionFee = gmxParams.executionFee;\n\n        // Prepare CreateDepositParams\n        IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams(\n            address(this),                     // receiver\n            gmxParams.callbackContract,        // callbackContract\n            gmxParams.uiFeeReceiver,           // uiFeeReceiver\n            marketAddress,\n            longToken,\n            shortToken,\n            longTokenSwapPath,\n            shortTokenSwapPath,\n            _minGmAmount,                  // minMarketTokens\n            gmxParams.shouldUnwrapNativeToken, // shouldUnwrapNativeToken\n            executionFee,\n            gmxParams.callbackGasLimit         // callbackGasLimit\n        );\n\n        // Approve token transfers if amounts are greater than 0\n        if (_longTokenAmount > 0) {\n            IERC20(longToken).safeIncreaseAllowance(routerConfig.router, _longTokenAmount);\n        }\n\n        if (_shortTokenAmount > 0) {\n            IERC20(shortToken).safeIncreaseAllowance(routerConfig.router, _shortTokenAmount);\n        }\n\n        // Prepare multicall arguments\n        bytes[] memory multicallArgs = new bytes[](4);\n\n        // Encode external contract calls for multicall\n        multicallArgs[0] = abi.encodeWithSignature(\"sendWnt(address,uint256)\", routerConfig.depositVault, executionFee);\n        multicallArgs[1] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", longToken, routerConfig.depositVault, _longTokenAmount);\n        multicallArgs[2] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", shortToken, routerConfig.depositVault, _shortTokenAmount);\n        multicallArgs[3] = abi.encodeWithSignature(\"createDeposit((address,address,address,address,address,address,address[],address[],uint256,bool,uint256,uint256))\", params);\n\n        // Execute multicall with optional value (executionFee)\n        bytes[] memory results = _exchangeRouter.multicall{value: executionFee}(multicallArgs);\n        ICallbackContract(gmxParams.callbackContract).addKey(bytes32(results[3]), ICallbackContract.State.Deposit);\n    }\n\n    // Internal function to sell GM tokens in a specified pool.\n    function sellGMToken(uint8 _poolId, uint256 marketAmount, uint256 lpAmount, uint256 _minLongTokenAmount, uint256 _minShortTokenAmount, address receiver) internal {\n        // Retrieve pool configuration\n        PoolConfig memory pool = pools[getPoolIndexById(_poolId)];\n\n        // Cast exchangeRouter to IExchangeRouter\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Define swap paths\n        address[] memory longTokenSwapPath;\n        address[] memory shortTokenSwapPath;\n\n        // Check if the contract has sufficient market token balance\n        uint256 balance = IERC20(pool.marketToken).balanceOf(address(this));\n        require(balance >= marketAmount && marketAmount > 0, \"GMX: Insufficient market token balance\");\n\n        // Create parameters for the external contract call\n        IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams(\n            receiver,                          // receiver\n            gmxParams.callbackContract,        // callbackContract\n            gmxParams.uiFeeReceiver,           // uiFeeReceiver\n            pool.marketToken,                  // market\n            longTokenSwapPath,                 // longTokenSwapPath\n            shortTokenSwapPath,                // shortTokenSwapPath\n            _minLongTokenAmount,               // minLongTokens\n            _minShortTokenAmount,              // minShortTokens\n            gmxParams.shouldUnwrapNativeToken, // shouldUnwrapNativeToken\n            gmxParams.executionFee,            // execution fee\n            gmxParams.callbackGasLimit         // callbackGasLimit\n        );\n\n        // Approve market token transfer\n        IERC20(pool.marketToken).safeIncreaseAllowance(routerConfig.router, marketAmount);\n\n        // Initialize an array to store multicall arguments\n        bytes[] memory multicallArgs = new bytes[](3);\n\n        // Encode external contract calls for multicall\n        multicallArgs[0] = abi.encodeWithSignature(\"sendWnt(address,uint256)\", routerConfig.withdrawVault, gmxParams.executionFee);\n        multicallArgs[1] = abi.encodeWithSignature(\"sendTokens(address,address,uint256)\", pool.marketToken, routerConfig.withdrawVault, marketAmount);\n        multicallArgs[2] = abi.encodeWithSignature(\"createWithdrawal((address,address,address,address,address[],address[],uint256,uint256,bool,uint256,uint256))\", params);\n\n        // Execute multicall with optional value (executionFee)\n        bytes[] memory results = _exchangeRouter.multicall{value: gmxParams.executionFee}(multicallArgs);\n    \n        ICallbackContract(gmxParams.callbackContract).addKey(bytes32(results[2]), ICallbackContract.State.Withdrawal);\n        ICallbackContract(gmxParams.callbackContract).addWithdrawalData(bytes32(results[2]), lpAmount, receiver);\n    }\n\n    // Create Gmx order with the gmx order params\n    function createGMOrder(IExchangeRouter.CreateOrderParams memory _params) internal {\n        require(_params.addresses.receiver == localVault, \"Invalid receiver\");\n\n        _params.addresses.callbackContract = gmxParams.callbackContract;\n        _params.numbers.callbackGasLimit = gmxParams.callbackGasLimit;\n        \n        // Cast exchangeRouter to IExchangeRouter\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Extract values from _params to improve readability\n        address initialCollateralToken = _params.addresses.initialCollateralToken;\n        uint256 initialCollateralDeltaAmount = _params.numbers.initialCollateralDeltaAmount;\n        uint256 executionFee = _params.numbers.executionFee;\n\n        if (\n            _params.orderType == IExchangeRouter.OrderType.MarketSwap ||\n            _params.orderType == IExchangeRouter.OrderType.LimitSwap ||\n            _params.orderType == IExchangeRouter.OrderType.MarketIncrease ||\n            _params.orderType == IExchangeRouter.OrderType.LimitIncrease\n        ) {\n\n            // Transfer initialCollateralToken from localVault to contract\n            IERC20(initialCollateralToken).safeTransferFrom(localVault, address(this), initialCollateralDeltaAmount);\n    \n            // Approve initialCollateralToken transfer\n            IERC20(initialCollateralToken).safeIncreaseAllowance(routerConfig.router, initialCollateralDeltaAmount);\n    \n            // Transfer initialCollateralToken to orderVault\n            _exchangeRouter.sendTokens(initialCollateralToken, routerConfig.orderVault, initialCollateralDeltaAmount);\n        }\n\n        // Send execution fee to orderVault\n        _exchangeRouter.sendWnt{value: executionFee}(routerConfig.orderVault, executionFee);\n\n        // Create the order using the external exchange router\n        bytes32 orderKey = _exchangeRouter.createOrder(_params);\n        \n        ICallbackContract(gmxParams.callbackContract).addKey(orderKey, ICallbackContract.State.Order);\n    }\n\n    // Cancels a deposit operation identified by the specified key using the configured exchange router.\n    function cancelDeposit(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the deposit with the specified key\n        _exchangeRouter.cancelDeposit(key);\n    }\n\n    // Cancels a withdrawal operation identified by the specified key using the configured exchange router.\n    function cancelWithdrawal(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the withdrawal with the specified key\n        _exchangeRouter.cancelWithdrawal(key);\n    }\n\n    // Cancels an order identified by the specified key using the configured exchange router.\n    function cancelOrder(bytes32 key) internal {\n        // Get the exchange router from the configuration\n        IExchangeRouter _exchangeRouter = IExchangeRouter(routerConfig.exchangeRouter);\n        \n        // Call the exchange router to cancel the order with the specified key\n        _exchangeRouter.cancelOrder(key);\n    }\n\n    // Get the pool token price with the poolId\n    function getPoolTokenPrice(uint8 _poolId, bool _maximize) public view returns (int256) {\n        require(poolExistsMap[_poolId], \"GMX: Pool with this poolId does not exist\");\n        \n        // Retrieve pool configuration\n        PoolConfig memory _pool = pools[getPoolIndexById(_poolId)];\n\n        // Cast exchangeRouter to IExchangeRouter for interacting with the external contract\n        IExchangeRouter exchangeRouterInstance = IExchangeRouter(routerConfig.exchangeRouter);\n\n        // Retrieve dataStore from the exchangeRouter\n        IDataStore dataStore = exchangeRouterInstance.dataStore();\n\n        // Define market properties for the external contract call\n        IMarket.Props memory marketProps = IMarket.Props(\n            _pool.marketToken,\n            _pool.indexToken,\n            _pool.longToken,\n            _pool.shortToken\n        );\n\n        // Fetch token prices for indexToken, longToken, and shortToken\n        IPrice.Props memory indexTokenPrice = getTokenPriceInfo(_pool.indexToken);\n        IPrice.Props memory longTokenPrice = getTokenPriceInfo(_pool.longToken);\n        IPrice.Props memory shortTokenPrice = getTokenPriceInfo(_pool.shortToken);\n\n        // Define additional parameters for the external contract call\n        bytes32 pnlFactorType = gmxParams.pnlFactorType;\n        bool maximize = _maximize;\n\n        // Call the external contract to get the market token price\n        (int256 marketTokenPrice, ) = IReader(routerConfig.reader).getMarketTokenPrice(\n            dataStore,\n            marketProps,\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        // Return the calculated market token price\n        return marketTokenPrice;\n    }\n\n    // Retrieves token price information, adjusting for decimals.\n    function getTokenPriceInfo(address token) public view returns (IPrice.Props memory) {\n        if(token == address(0)) return IPrice.Props(0, 0);\n\n        // Create an instance of TokenPriceConsumer for fetching token prices\n        TokenPriceConsumer priceConsumer = TokenPriceConsumer(tokenPriceConsumer);\n\n        uint256 tokenDecimal;\n        if(isContract(token)) {\n            tokenDecimal = IERC20Metadata(token).decimals();\n        } else {\n            tokenDecimal = tokenDecimalList[token];        \n        }\n        \n        IPrice.Props memory tokenPrice = IPrice.Props(\n            convertDecimals(priceConsumer.getTokenPrice(token), priceConsumer.decimals(token), MARKET_TOKEN_PRICE_DECIMALS - tokenDecimal),\n            convertDecimals(priceConsumer.getTokenPrice(token), priceConsumer.decimals(token), MARKET_TOKEN_PRICE_DECIMALS - tokenDecimal)\n        );\n        return tokenPrice;\n    }\n\n    // Retrieves the long and short tokens allowed in a pool.\n    function getAllowedTokens(uint8 _poolId) public view returns (address[] memory) {\n        // Create an empty array to return if the pool does not exist\n        address[] memory emptyArray;\n\n        // Check if the pool with the given ID exists\n        if (!poolExistsMap[_poolId]) {\n            // Return an empty array if the pool does not exist\n            return emptyArray;\n        }\n\n        // Create an array to store the addresses of allowed tokens (long and short)\n        address[] memory tokens = new address[](2);\n\n        // Retrieve the index of the pool in the pools array\n        uint256 index = getPoolIndexById(_poolId);\n\n        // Retrieve the pool configuration using the index\n        PoolConfig memory pool = pools[index];\n\n        // Assign the long and short token addresses to the array\n        tokens[0] = pool.longToken;\n        tokens[1] = pool.shortToken;\n\n        // Return the array containing the addresses of allowed tokens\n        return tokens;\n    }   \n\n    // Retrieves information about a pool identified by its ID.\n    function getPoolTokenInfo(uint8 _poolId) public view returns (address, uint8, uint256) {\n        // Check if the pool with the given ID exists\n        if (!poolExistsMap[_poolId]) {\n            // Return default values if the pool does not exist\n            return (address(0), 0, 0);\n        }\n\n        // Retrieve the index of the pool in the pools array\n        uint256 index = getPoolIndexById(_poolId);\n\n        // Retrieve the pool configuration using the index\n        PoolConfig memory pool = pools[index];\n\n        // Get the decimals of the market token associated with the pool\n        uint8 decimals = IERC20Metadata(pool.marketToken).decimals();\n\n        // Get the balance of the market token held by this contract\n        uint256 balance = IERC20(pool.marketToken).balanceOf(address(this));\n\n        // Return the market token address, decimals, and balance in a tuple\n        return (pool.marketToken, decimals, balance);\n    }\n\n    // Converts an amount from one decimal precision to another.\n    function convertDecimals(uint256 _amount, uint256 _from, uint256 _to) public pure returns (uint256) {\n        if(_from >= _to) return _amount / 10 ** (_from - _to);\n        else return _amount * 10 ** (_to - _from);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function withdrawFee(uint256 _amount) public onlyOwner {\n        // get the amount of Ether stored in this contract\n        uint amount = address(this).balance;\n        require(amount >= _amount, \"Vault: Invalid withdraw amount.\");\n                                                  \n        require(treasury != address(0), \"Vault: Invalid treasury\");\n        (bool success, ) = treasury.call{value: _amount}(\"\");\n        require(success, \"Vault: Failed to send Ether\");\n    }\n\n    receive() external payable {}\n    fallback() external payable {}\n    \n    function withdrawStuckEth(uint256 amount) external onlyOwner {\n        (bool success, ) = treasury.call{\n            value: amount\n        } (\"\");\n        require(success);\n    }\n\n    // Public view function to determine whether the given address is a contract or an externally-owned account (EOA).\n    // It uses the assembly block to efficiently check the size of the code at the specified address.\n    // If the size of the code (extcodesize) is greater than 0, the address is considered a contract.\n    // Returns true if the address is a contract and false if it is an externally-owned account.\n    function isContract(address _addr) public view returns (bool) {\n        uint32 size;\n\n        // Use assembly to get the size of the code at the specified address.\n        assembly {\n            size := extcodesize(_addr)\n        }\n\n        // Return true if the size of the code is greater than 0, indicating a contract.\n        return (size > 0);\n    }\n}"
    },
    "contracts/vaults/theseus/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n// Libraries\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"../../interfaces/vaults/IVaultLocker.sol\";\nimport \"../TokenPriceConsumer.sol\";\n\ncontract Vault is Ownable, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constant representing the number of decimals for the MOZAIC token.\n    uint256 public constant MOZAIC_DECIMALS = 6;\n\n    // Constant representing the number of decimals for the ASSET.\n    uint256 public constant ASSET_DECIMALS = 36;\n\n    // A constant representing the denominator for basis points (BP). Used for percentage calculations.\n    uint256 public constant BP_DENOMINATOR = 1e4;\n\n    // A constant representing the maximum fee percentage allowed (1000 basis points or 10% in this case).\n    uint256 public constant MAX_FEE = 1e3;\n\n    // Struct defining the properties of a Plugin.\n    struct Plugin {\n        address pluginAddress;  // Address of the plugin contract.\n        uint8 pluginId;       // Unique identifier for the plugin.\n    }\n    \n    /* ========== STATE VARIABLES ========== */\n    // Stores the address of the master contract.\n    address public master;\n\n    // Stores the address of the contract admin.\n    address public admin;\n\n    // Stores the address of the treasury, which is payable for receiving funds.\n    address payable public treasury;\n\n    // Stores the address of the token price consumer contract.\n    address public tokenPriceConsumer;\n\n    // Maps plugin IDs to their respective index.\n    mapping(uint8 => uint256) public pluginIdToIndex;\n\n    // An array to store instances of the Plugin struct.\n    Plugin[] public plugins;\n\n    // Maps token addresses to boolean values indicating whether the token is accepted.\n    mapping(address => bool) public acceptedTokenMap;\n\n    // An array of accepted token addresses.\n    address[] public acceptedTokens;\n\n    // Maps token addresses to boolean values indicating whether deposits are allowed for the token.\n    mapping(address => bool) public depositAllowedTokenMap;\n\n    // An array of token addresses for which deposits are allowed.\n    address[] public depositAllowedTokens;\n\n    // Stores the ID of the currently selected plugin.\n    uint8 public selectedPluginId;\n\n    // Stores the ID of the currently selected pool.\n    uint8 public selectedPoolId;\n\n    // An array of addresses representing users who can lock assets in the vault.\n    address[] public vaultLockers;\n\n    // An array of addresses representing managers who have control over the vault.\n    address[] public vaultManagers;\n\n    // A rate used to convert LP (Liquidity Provider) tokens to a standard decimal format (18 decimals in this case).\n    uint256 public lpRate = 1e18;\n\n    // The percentage of fees collected by the protocol for each transaction.\n    uint256 public protocolFeePercentage;\n\n    // The total protocol fee held in the vault.\n    uint256 public protocolFeeInVault;\n\n    // The minimum execution fee required when depositing funds into the vault.\n    uint256 public depositMinExecFee;\n\n    // The minimum execution fee required when withdrawing funds from the vault.\n    uint256 public withdrawMinExecFee;\n\n\n    /* ========== EVENTS ========== */\n    event AddPlugin(uint8 _pluginId, address _pluginAddress);\n    event RemovePlugin(uint8 _pluginId);\n    event Execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes _payload);\n    event MasterUpdated(address _oldMaster, address _newMaster);\n    event AdminUpdated(address _oldAdmin, address _newAdmin);\n    event TokenPriceConsumerUpdated(address _oldTokenPriceConsumer, address _newTokenPriceConsumer);\n    event SetTreasury(address payable treasury);\n    event SetProtocolFeePercentage(uint256 _protocolFeePercentage);\n    event SetExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee);\n    event SetVaultLockers(address[] _vaultLockers);\n    event SetVaultManagers(address[] _vaultManagers);\n    event UpdateLiquidityProviderRate(uint256 _previousRate, uint256 _lpRate);\n    event AddAcceptedToken(address _token);\n    event RemoveAcceptedToken(address _token);\n    event AddDepositAllowedToken(address _token);\n    event RemoveDepositAllowedToken(address _token);\n    event AddDepositRequest(address _token, uint256 _amount);\n    event AddWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver);\n    event SelectPluginAndPool(uint8 _pluginId, uint8 _poolId);\n    event ApproveTokens(uint8 _pluginId, address[] _tokens, uint256[] _amounts);\n    event WithdrawProtocolFee(address _token, uint256 _amount);\n    event StakeToSelectedPool(uint8 _selectedPluginId, uint8 _selectedPoolId, address _token, uint256 _tokenAmount);\n\n\n    /* ========== MODIFIERS ========== */\n    // Modifier allowing only the master contract to execute the function.\n    modifier onlyMaster() {\n        require(msg.sender == master, \"Vault: caller must be master\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Vault: caller must be admin\");\n        _;\n    }\n\n\n    // Modifier allowing only the vault lockers to execute the function.\n    modifier onlyVaultLockers() {\n        bool isVaultLocker = false;\n        for(uint256 i  = 0; i < vaultLockers.length; i++) {\n            if(vaultLockers[i] == msg.sender) {\n                isVaultLocker = true;\n                break;\n            }\n        }\n        require(isVaultLocker, \"Vault: Invalid vault locker\");\n        _;\n    }\n\n    // Modifier allowing only the vault managers to execute the function.\n    modifier onlyVaultManagers() {\n        bool isVaultManager = false;\n        for(uint256 i  = 0; i < vaultManagers.length; i++) {\n            if(vaultManagers[i] == msg.sender) {\n                isVaultManager = true;\n                break;\n            }\n        }\n        require(isVaultManager, \"Vault: Invalid vault manager\");\n        _;\n    }\n\n    /* ========== CONFIGURATION ========== */\n    // Constructor for the Mozaic Theseus LPToken contract, inheriting from ERC20.\n    constructor(address _master,address _admin, address _tokenPriceConsumer, address payable _treasury) ERC20(\"Mozaic Theseus LP\", \"MOZ-THE-LP\") Ownable(msg.sender){\n        require(_master != address(0), \"Vault: Invalid Address\");\n        require(_admin != address(0), \"Vault: Invalid Address\");\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n        require(_treasury != address(0), \"Vault: Invalid Address\");\n\n        master = _master;\n        tokenPriceConsumer = _tokenPriceConsumer;\n        treasury = _treasury;\n        admin = _admin;\n    }\n\n    // Allows the owner to set a new master address for the Vault.\n    function setMaster(address _newMaster) external onlyOwner {\n        // Ensure that the new master address is valid.\n        require(_newMaster != address(0), \"Vault: Invalid Address\");\n\n        // Store the current master address before updating.\n        address _oldMaster = master;\n\n        // Update the master address to the new value.\n        master = _newMaster;\n\n        // Emit an event to log the master address update.\n        emit MasterUpdated(_oldMaster, _newMaster);\n    }\n\n    // Allows the owner to set a new admin address for the Vault.\n    function setAdmin(address _newAdmin) external onlyOwner {\n        // Ensure that the new admin address is valid.\n        require(_newAdmin != address(0), \"Vault: Invalid Address\");\n\n        // Store the current admin address before updating.\n        address _oldAdmin = admin;\n\n        // Update the admin address to the new value.\n        admin = _newAdmin;\n\n        // Emit an event to log the admin address update.\n        emit MasterUpdated(_oldAdmin, _newAdmin);\n    }\n\n    // Allows the owner to set the address of the token price consumer contract.\n    function setTokenPriceConsumer(address _tokenPriceConsumer) public onlyOwner {\n        // Ensure that the new token price consumer address is valid.\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n\n        // Store the current token price consumer address before updating.\n        address _oldTokenPriceConsumer = tokenPriceConsumer;\n\n        // Update the token price consumer address to the new value.\n        tokenPriceConsumer = _tokenPriceConsumer;\n\n        // Emit an event to log the token price consumer address update.\n        emit TokenPriceConsumerUpdated(_oldTokenPriceConsumer, _tokenPriceConsumer);\n    }\n\n    // Allows the owner to set the address of the treasury.\n    function setTreasury(address payable _treasury) public onlyOwner {\n        // Ensure that the new treasury address is valid.\n        require(_treasury != address(0), \"Vault: Invalid address\");\n\n        // Update the treasury address to the new value.\n        treasury = _treasury;\n\n        // Emit an event to log the treasury address update.\n        emit SetTreasury(_treasury);\n    }\n\n    // Allows the master contract to select a plugin and pool.\n    function selectPluginAndPool(uint8 _pluginId, uint8 _poolId) onlyAdmin public {\n        // Set the selectedPluginId and selectedPoolId to the provided values.\n        selectedPluginId = _pluginId;\n        selectedPoolId = _poolId;\n        emit SelectPluginAndPool(_pluginId, _poolId);\n    }\n\n    // Sets the execution fees for deposit and withdrawal transactions.\n    function setExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee) public onlyAdmin {\n        // Set the deposit minimum execution fee\n        depositMinExecFee = _depositMinExecFee;\n\n        // Set the withdrawal minimum execution fee\n        withdrawMinExecFee = _withdrawMinExecFee;\n\n        // Emit an event to log the changes in execution fees\n        emit SetExecutionFee(_depositMinExecFee, _withdrawMinExecFee);\n    }\n\n\n    // Allows the owner to add a new accepted token.\n    function addAcceptedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == false) {\n            // Set the token as accepted, add it to the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = true;\n            acceptedTokens.push(_token);\n            emit AddAcceptedToken(_token);\n        } else {\n            // Revert if the token already exists in the accepted tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    // Allows the owner to remove an accepted token.\n    function removeAcceptedToken(address _token) external onlyOwner {\n        // Check if the token exists in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == true) {\n            // Set the token as not accepted, remove it from the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = false;\n            for (uint256 i = 0; i < acceptedTokens.length; ++i) {\n                if (acceptedTokens[i] == _token) {\n                    acceptedTokens[i] = acceptedTokens[acceptedTokens.length - 1];\n                    acceptedTokens.pop();\n                    emit RemoveAcceptedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the accepted tokens.\n        revert(\"Vault: Non-accepted token.\");\n    }\n\n    // Allows the owner to add a new deposit allowed token.\n    function addDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == false) {\n            // Set the token as allowed for deposit, add it to the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = true;\n            depositAllowedTokens.push(_token);\n            emit AddDepositAllowedToken(_token);\n        } else {\n            // Revert if the token already exists in the deposit allowed tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    // Allows the owner to remove a deposit allowed token.\n    function removeDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token exists in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == true) {\n            // Set the token as not allowed for deposit, remove it from the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = false;\n            for (uint256 i = 0; i < depositAllowedTokens.length; ++i) {\n                if (depositAllowedTokens[i] == _token) {\n                    depositAllowedTokens[i] = depositAllowedTokens[depositAllowedTokens.length - 1];\n                    depositAllowedTokens.pop();\n                    emit RemoveDepositAllowedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the deposit allowed tokens.\n        revert(\"Vault: Non-deposit allowed token.\");\n    }\n\n    // Allows the owner to add a new plugin to the vault.\n    function addPlugin(uint8 _pluginId, address _pluginAddress) external onlyOwner {\n        // Ensure that the pluginId is not zero and does not already exist.\n        require(_pluginId != 0, \"Vault: PluginId cannot be zero\");\n        require(pluginIdToIndex[_pluginId] == 0, \"Plugin with this ID already exists\");\n\n        // Create a new Plugin instance and add it to the plugins array.\n        plugins.push(Plugin(_pluginAddress, _pluginId));\n        \n        // Update the mapping with the index of the added plugin.\n        pluginIdToIndex[_pluginId] = plugins.length;\n\n        // Emit an event to log the addition of a new plugin.\n        emit AddPlugin(_pluginId, _pluginAddress);\n    }\n\n    // Allows the owner to remove a plugin from the vault.\n    function removePlugin(uint8 _pluginId) external onlyOwner {\n        // Ensure that the pluginId exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Get the index of the plugin in the array.\n        uint256 pluginIndex = pluginIdToIndex[_pluginId] - 1;\n        \n        // Delete the mapping entry for the removed plugin.\n        delete pluginIdToIndex[_pluginId];\n\n        if (pluginIndex != plugins.length - 1) {\n            // If the removed plugin is not the last one, replace it with the last plugin in the array.\n            Plugin memory lastPlugin = plugins[plugins.length - 1];\n            plugins[pluginIndex] = lastPlugin;\n            pluginIdToIndex[lastPlugin.pluginId] = pluginIndex + 1;\n        }\n\n        // Remove the last element from the array.\n        plugins.pop();\n\n        // Emit an event to log the removal of a plugin.\n        emit RemovePlugin(_pluginId);\n    }\n\n    // Function to set the protocol fee percentage. Only callable by the owner of the contract.\n    function setProtocolFeePercentage(uint256 _protocolFeePercentage) external onlyOwner {\n        // Ensure that the provided protocol fee percentage does not exceed the maximum allowed fee.\n        require(_protocolFeePercentage <= MAX_FEE, \"Vault: protocol fee exceeds the max fee\");\n        \n        // Update the protocol fee percentage.\n        protocolFeePercentage = _protocolFeePercentage;\n\n        // Emit an event to log the change in protocol fee percentage.\n        emit SetProtocolFeePercentage(_protocolFeePercentage);\n    }\n\n    // Function to set the addresses of users who can lock assets in the vault. Only callable by the owner.\n    function setVaultLockers(address[] memory _vaultLockers) external onlyOwner {\n        // Update the array of vault lockers with the provided addresses.\n        vaultLockers = _vaultLockers;\n\n        // Emit an event to log the update of vault lockers with the provided addresses.\n        emit SetVaultLockers(_vaultLockers);\n    }\n\n    // Function to set the addresses of managers who have control over the vault. Only callable by the owner.\n    function setVaultManagers(address[] memory _vaultManagers) external onlyOwner {\n        // Update the array of vault managers with the provided addresses.\n        vaultManagers = _vaultManagers;\n\n        // Emit an event to log the update of vault managers with the provided addresses.\n        emit SetVaultManagers(_vaultManagers);\n\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n    \n    // Allows users to initiate a deposit request by converting tokens to LP tokens and staking them into the selected pool.\n    function addDepositRequest(address _token, uint256 _tokenAmount, address _receiver, bytes memory _payload) external payable nonReentrant {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        require(msg.value >= depositMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure the deposited token is allowed for deposit in the vault.\n        require(isDepositAllowedToken(_token), \"Vault: Invalid token\");\n        \n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Ensure a valid and positive token amount is provided.\n        require(_tokenAmount > 0, \"Vault: Invalid token amount\");\n\n        // Calculate the USD value of the deposited tokens.\n        uint256 amountUsd = calculateTokenValueInUsd(_token, _tokenAmount);\n\n        require(amountUsd >= 10 ** (ASSET_DECIMALS - 2), \"Invalid token amount\");\n\n        // Convert the USD value to the corresponding LP token amount.\n        uint256 lpAmountToMint = convertAssetToLP(amountUsd);\n\n        // Ensure that there is a sufficient LP amount to mint.\n        require(lpAmountToMint > 0, \"Vault: Insufficient amount\");\n\n        // Transfer the deposited tokens from the user to the vault.\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _tokenAmount);\n\n        // Mint the calculated LP tokens and send them to the user.\n        _mint(_receiver, lpAmountToMint);\n\n        // Emit an event to log the deposit request.\n        emit AddDepositRequest(_token, _tokenAmount);\n\n        // Stake the minted LP tokens to the selected pool.\n        stakeToSelectedPool(_token, _tokenAmount, _payload);\n    }\n\n\n    // Internal function to stake a specified token amount to the selected pool using the configured plugin.\n    function stakeToSelectedPool(address _token, uint256 _tokenAmount, bytes memory _payload) internal {\n        // Retrieve the list of allowed tokens for the selected plugin and pool.\n        address[] memory allowedTokens = getTokensByPluginAndPoolId(selectedPluginId, selectedPoolId);\n\n        // Iterate through the allowed tokens to find the matching token.\n        for (uint256 i = 0; i < allowedTokens.length; i++) {\n            if (allowedTokens[i] == _token) {\n                // Create an array to represent token amounts, with the target token's amount set accordingly.\n                uint256[] memory _amounts = new uint256[](allowedTokens.length);\n                _amounts[i] = _tokenAmount;\n\n                // Encode the payload for the 'Stake' action using the selected plugin and pool.\n                bytes memory payload = abi.encode(uint8(selectedPoolId), allowedTokens, _amounts, _payload);\n\n                // Ensure that the specified plugin exists.\n                require(pluginIdToIndex[selectedPluginId] != 0, \"Plugin with this ID does not exist\");\n\n                // Retrieve the plugin address based on the provided plugin ID.\n                address plugin = plugins[pluginIdToIndex[selectedPluginId] - 1].pluginAddress;\n\n                // Increase the allowance for the plugin to spend the specified token amount.\n                IERC20(allowedTokens[i]).safeIncreaseAllowance(plugin, _tokenAmount);\n\n                // Execute the specified action on the plugin with the provided payload.\n                IPlugin(plugin).execute(IPlugin.ActionType.Stake, payload);\n                \n                emit StakeToSelectedPool(selectedPluginId, selectedPoolId, _token, _tokenAmount);\n                // Exit the function after successfully staking the token.\n                return;\n            }\n        }     \n        revert(\"Vault: deposit token not in allowedTokens\");\n    }\n\n    // Function to add a withdrawal request for a specified LP token amount from a selected pool using a specified plugin.\n    function addWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver, bytes memory payload) external payable {\n        // Ensure that the vault is not locked before processing withdrawal requests.\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Ensure that the user has provided sufficient execution fee for the withdrawal.\n        require(msg.value >= withdrawMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure a valid and positive LP token amount is provided for withdrawal.\n        require(_lpAmount > 0, \"Vault: Invalid LP token amount\");\n\n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Transfer the specified amount of LP tokens from the user to the contract.\n        this.transferFrom(msg.sender, address(this), _lpAmount);\n\n        // Convert the LP token amount to its equivalent USD value.\n        uint256 usdAmountToWithdraw = convertLPToAsset(_lpAmount);\n\n        // Retrieve information about the selected pool token, including its decimals and price.\n        (, uint8 poolTokenDecimals, ) = getPoolTokenInfo(_pluginId, _poolId);\n\n        // Get the current price of the pool token.\n        uint256 poolTokenPrice = getPoolTokenPrice(_pluginId, _poolId);\n\n        // Calculate the amount of pool tokens equivalent to the USD value of the LP token withdrawal.\n        uint256 poolTokenAmount = convertDecimals(usdAmountToWithdraw, 6, poolTokenDecimals) / poolTokenPrice;\n\n        // Encode the payload for the 'Unstake' action using the specified pool and LP token details.\n        bytes memory _payload = abi.encode(_poolId, poolTokenAmount, _lpAmount, _receiver, payload);\n\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Execute the 'Unstake' action on the plugin with the provided payload.\n        IPlugin(plugin).execute(IPlugin.ActionType.Unstake, _payload);\n\n        emit AddWithdrawalRequest(_lpAmount, _pluginId, _poolId,  _receiver);\n    }\n\n    // Function to get the current price of the pool token for a specified pool using a specified plugin.\n    function getPoolTokenPrice(uint8 _pluginId, uint8 _poolId) public view returns (uint256) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token price.\n        int256 tokenPrice = IPlugin(plugin).getPoolTokenPrice(_poolId, true);\n\n        // Ensure that the retrieved token price is positive.\n        require(tokenPrice > 0, \"Vault: Pool token price is negative.\");\n\n        // Convert the token price to an unsigned integer and return it.\n        return uint256(tokenPrice);\n    }\n\n    // Function to get information about the pool token, including its address, decimals, and balance for a specified pool using a specified plugin.\n    function getPoolTokenInfo(uint8 _pluginId, uint8 _poolId) public view returns (address token, uint8 decimal, uint256 balance) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token information.\n        return IPlugin(plugin).getPoolTokenInfo(_poolId);\n    }\n\n    \n    /* ========== MASTER FUNCTIONS ========== */\n    \n    // Allows the master contract to execute actions on a specified plugin.\n    function execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes memory _payload) public onlyMaster nonReentrant {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // If the action type is 'Stake', approve tokens for staking according to the payload.\n        if (_actionType == IPlugin.ActionType.Stake) {\n            (, address[] memory _tokens, uint256[] memory _amounts, ) = abi.decode(_payload, (uint8, address[], uint256[], bytes));\n            require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n            // Iterate through the tokens and approve them for staking.\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (_amounts[i] > 0) {\n                    IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n                }\n            }\n        } else if (_actionType == IPlugin.ActionType.Unstake) {\n            ( , , , address receiver, ) = abi.decode(_payload, (uint8, uint256, uint256, address, bytes));\n\n            // Ensure that the receiver address is the vault itself.\n            require(receiver == address(this), \"Invalid receiver\");\n        }\n\n        // Execute the specified action on the plugin with the provided payload.\n        IPlugin(plugin).execute(_actionType, _payload);\n\n        // Emit an event to log the execution of the plugin action.\n        emit Execute(_pluginId, _actionType, _payload);\n    }\n\n    // Allows the master contract to approve tokens for a specified plugin based on the provided payload.\n    function approveTokens(uint8 _pluginId, address[] memory _tokens, uint256[] memory _amounts) external onlyMaster nonReentrant {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Decode the payload to obtain the list of tokens and corresponding amounts to approve.\n        // (address[] memory _tokens, uint256[] memory _amounts) = abi.decode(_payload, (address[], uint256[]));\n        require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n        // Iterate through the tokens and approve them for the plugin.\n        for (uint256 i; i < _tokens.length; ++i) {\n            IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n        }\n        emit ApproveTokens(_pluginId, _tokens, _amounts);\n    }\n\n    // Updates the liquidity provider rate based on the current market rate.\n    function updateLiquidityProviderRate() internal {\n        // Store the previous liquidity provider rate\n        uint256 previousRate = lpRate;\n        \n        // Calculate the current liquidity provider rate from external source\n        uint256 currentRate = getCurrentLiquidityProviderRate();\n        \n        // Check if the current rate is higher than the previous rate\n        if (currentRate > previousRate) {\n            // Calculate the change in rate and update total profit\n            uint256 deltaRate = currentRate - previousRate;\n        \n            // Calculate total profit in the protocol's base asset\n            uint256 totalProfit = convertDecimals(deltaRate * totalSupply(), 18 + MOZAIC_DECIMALS, ASSET_DECIMALS);\n            \n            // Calculate protocol fee as a percentage of total profit\n            uint256 protocolFee = (totalProfit * protocolFeePercentage) / (BP_DENOMINATOR);\n            \n            // Accumulate protocol fee in the vault\n            protocolFeeInVault += protocolFee;\n\n            // Update the liquidity provider rate\n            lpRate = getCurrentLiquidityProviderRate();\n        } else {\n            // Update the liquidity provider rate directly\n            lpRate = currentRate;\n        }\n\n        // Emit an event to log the update in liquidity provider rate\n        emit UpdateLiquidityProviderRate(previousRate, lpRate);\n    }\n\n    // Withdraws protocol fees stored in the vault for a specific token.\n    function withdrawProtocolFee(address _token) external onlyMaster nonReentrant {\n        require(isAcceptedToken(_token), \"Vault: Invalid token\");\n\n        // Calculate the token amount from the protocol fee in the vault\n        uint256 tokenAmount = calculateTokenAmountFromUsd(_token, protocolFeeInVault);\n\n        // Get the token balance of this contract\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n\n        // Determine the transfer amount, ensuring it doesn't exceed the token balance\n        uint256 transferAmount = tokenBalance >= tokenAmount ? tokenAmount : tokenBalance;\n\n        if(tokenAmount != 0) {        \n            // Update the protocol fee in the vault after the withdrawal\n            protocolFeeInVault = protocolFeeInVault - ((protocolFeeInVault * transferAmount) / (tokenAmount));\n\n            // Safely transfer the tokens to the treasury address\n            IERC20(_token).safeTransfer(treasury, transferAmount);\n        }\n        \n        // Emit an event to log the withdrawal\n        emit WithdrawProtocolFee(_token, transferAmount);\n    }\n\n    // Transfers the execution fee to the specified plugin.\n    function transferExecutionFee(uint8 _pluginId, uint256 _amount) external onlyMaster nonReentrant {\n        // Retrieve information about the specified plugin\n        Plugin memory plugin = getPlugin(_pluginId);\n        \n        // Check if the contract has sufficient balance for the transfer\n        require(_amount <= address(this).balance, \"Vault: Insufficient balance\");\n        \n        // Attempt to transfer Ether to the plugin's address\n        (bool success, ) = plugin.pluginAddress.call{value: _amount}(\"\");\n        \n        // Revert if the Ether transfer to the plugin fails\n        require(success, \"Vault: Failed to send Ether\");\n    }\n \n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // Retrieve the array of plugins registered in the vault.\n    function getPlugins() public view returns (Plugin[] memory) {\n        return plugins;\n    }\n\n    // Retrieve the total count of registered plugins in the vault.\n    function getPluginsCount() public view returns (uint256) {\n        return plugins.length;\n    }\n\n    // Retrieve details about a specific plugin based on its unique identifier.\n    function getPlugin(uint8 _pluginId) public view returns (Plugin memory) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve and return details about the specified plugin.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n        return plugin;\n    }\n\n    // Retrieves the current liquidity provider rate.\n    function getCurrentLiquidityProviderRate() public view returns(uint256) {\n        uint256 _totalAssets = totalAssetInUsd() > protocolFeeInVault ? totalAssetInUsd() - protocolFeeInVault: 0;\n        \n        // Variable to store the current rate\n        uint256 currentRate;\n\n         // Check if total supply or total assets is zero\n        if (_totalAssets <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            currentRate = 1e18;\n        } else {\n            // Convert total assets to the desired decimals\n            uint256 adjustedAssets = convertDecimals(_totalAssets, ASSET_DECIMALS, MOZAIC_DECIMALS + 18);\n\n            // Calculate the current rate\n            currentRate = adjustedAssets / totalSupply();\n        }\n        return currentRate;\n    }\n\n    // Calculate the total value of assets held by the vault, including liquidity from registered plugins\n    // and the USD value of accepted tokens held in the vault.\n    function totalAssetInUsd() public view returns (uint256 _totalAsset) {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Iterate through registered plugins to calculate their total liquidity.\n        for (uint8 i; i < plugins.length; ++i) {\n            _totalAsset += IPlugin(plugins[i].pluginAddress).getTotalLiquidity();\n        }\n\n        // Iterate through accepted tokens to calculate their total USD value.\n        for (uint256 i; i < acceptedTokens.length; ++i) {\n            // Calculate the USD value of the token based on its balance in the vault.\n            _totalAsset += calculateTokenValueInUsd(acceptedTokens[i], IERC20(acceptedTokens[i]).balanceOf(address(this)));\n        }\n\n        // Return the total calculated asset value.\n        return _totalAsset + 10 ** ASSET_DECIMALS;\n    }\n\n    // Check if a given token is accepted by the vault.\n    function isAcceptedToken(address _token) public view returns (bool) {\n        return acceptedTokenMap[_token];\n    }\n\n    // Check if a given token is allowed for deposit in the vault.\n    function isDepositAllowedToken(address _token) public view returns (bool) {\n        return depositAllowedTokenMap[_token];\n    }\n\n    function getAcceptedTokens() public view returns (address[] memory) {\n        return acceptedTokens;\n    }\n\n    function getDepositAllowedTokens() public view returns (address[] memory) {\n        return depositAllowedTokens;\n    }\n\n    // Retrieve the list of tokens allowed for a specific pool associated with a plugin.\n    // Returns an array of token addresses based on the provided plugin and pool IDs.\n    function getTokensByPluginAndPoolId(uint8 _pluginId, uint8 _poolId) public view returns (address[] memory) {\n        // Initialize an array to store the allowed tokens for the specified pool.\n        address[] memory poolAllowedTokens;\n\n        // If the specified plugin does not exist, return an empty array.\n        if (pluginIdToIndex[_pluginId] == 0) {\n            return poolAllowedTokens;\n        }\n\n        // Retrieve the plugin information based on the provided plugin ID.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n\n        // Retrieve the allowed tokens for the specified pool from the associated plugin.\n        poolAllowedTokens = IPlugin(plugin.pluginAddress).getAllowedTokens(_poolId);\n\n        // Return the array of allowed tokens for the specified pool.\n        return poolAllowedTokens;\n    }\n\n    // Function to get the status of the vault, indicating whether it is locked or unlocked.\n    function getVaultStatus() public view returns (bool) {\n        // Initialize the status as true, assuming the vault is initially unlocked.\n        bool status = true;\n\n        // Iterate through the array of vault lockers to check their individual status.\n        for(uint256 i = 0; i < vaultLockers.length; i++) {\n            // Check the status of the current vault locker.\n            if(IVaultLocker(vaultLockers[i]).getLockerStatus() == false) {\n                // If any vault locker reports that it is locked, set the overall vault status to false and exit the loop.\n                status = false;\n                break;\n            }\n        }\n\n        // Return the overall status of the vault.\n        return status;\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    // Calculate the USD value of a given token amount based on its price and decimals.\n    function calculateTokenValueInUsd(address _tokenAddress, uint256 _tokenAmount) public view returns (uint256) {\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Retrieve the token price from the price consumer.\n        uint256 tokenPrice = TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        return convertDecimals(_tokenAmount * tokenPrice, tokenDecimals + priceConsumerDecimals, ASSET_DECIMALS);\n    }\n\n    // Calculate the token amount corresponding to a given USD value based on token price and decimals.\n    function calculateTokenAmountFromUsd(address _tokenAddress, uint256 _tokenValueUsd) public view returns (uint256) {\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Convert the USD value to the desired ASSET_DECIMALS.\n        uint256 normalizedValue = convertDecimals(_tokenValueUsd, ASSET_DECIMALS, tokenDecimals + priceConsumerDecimals);\n\n        // Calculate the token amount based on the normalized value and token price.\n        uint256 tokenAmount = normalizedValue / TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        // Return the calculated token amount.\n        return tokenAmount;\n    }\n\n    /* ========== CONVERT FUNCTIONS ========== */\n\n    // Convert an amount from one decimal precision to another.\n    function convertDecimals(uint256 _amount, uint256 _from, uint256 _to) public pure returns (uint256) {\n        // If the source decimal precision is greater than or equal to the target, perform division.\n        if (_from >= _to) {\n            return _amount / 10 ** (_from - _to);\n        } else {\n            // If the target decimal precision is greater than the source, perform multiplication.\n            return _amount * 10 ** (_to - _from);\n        }\n    }\n\n    // Convert an asset amount to LP tokens based on the current total asset and total LP token supply.\n    function convertAssetToLP(uint256 _amount) public view returns (uint256) {\n        // If the total asset is zero, perform direct decimal conversion.\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, ASSET_DECIMALS, MOZAIC_DECIMALS);\n        }\n        \n        // Perform conversion based on the proportion of the provided amount to the total asset.\n        return (_amount * totalSupply()) / _totalAssetInUsd;\n    }\n\n    // Convert LP tokens to an equivalent asset amount based on the current total asset and total LP token supply.\n    function convertLPToAsset(uint256 _amount) public view returns (uint256) {\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n\n        // If the total LP token supply is zero, perform direct decimal conversion.\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, MOZAIC_DECIMALS, ASSET_DECIMALS);\n        }\n        // Perform conversion based on the proportion of the provided amount to the total LP token supply.\n        return (_amount * _totalAssetInUsd) / totalSupply();\n    }\n\n    // Retrieve the decimal precision of the token (MOZAIC_DECIMALS).\n    function decimals() public view virtual override returns (uint8) {\n        return uint8(MOZAIC_DECIMALS);\n    }\n\n    // Function to get the total supply of the LP tokens, including an additional fixed supply represented by 10^MOZAIC_DECIMALS.\n    function totalSupply() public view virtual override returns (uint256) {\n        // Retrieve the original total supply from the parent contract and add an additional fixed supply.\n        return super.totalSupply() + 10 ** MOZAIC_DECIMALS;\n    }\n\n    // Function to burn a specified amount of LP tokens. Only callable by vault managers.\n    function burnLP(uint256 _lpAmount) external onlyVaultManagers {\n        // Burn the specified amount of LP tokens from the contract's balance.\n        _burn(address(this), _lpAmount);\n    }\n\n    // Function to transfer a specified amount of LP tokens to a given account. Only callable by vault managers.\n    function transferLP(address _account, uint256 _lpAmount) external onlyVaultManagers {\n        // Transfer the specified amount of LP tokens from the contract to the target account.\n        this.transfer(_account, _lpAmount);\n    }\n\n    /* ========== TREASURY FUNCTIONS ========== */\n    receive() external payable {}\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}"
    },
    "contracts/vaults/TokenPriceConsumer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\ncontract TokenPriceConsumer is Ownable {\n    mapping(address => AggregatorV3Interface) private tokenPriceFeeds;\n    \n    mapping(address => uint256) private tokenHeartbeatDurations;\n\n    constructor(address[] memory tokenAddresses, address[] memory priceFeedAddresses, uint256[] memory heartbeatDurations) Ownable(msg.sender) {\n        require(tokenAddresses.length == priceFeedAddresses.length, \"Arrays length mismatch\");\n        require(tokenAddresses.length == heartbeatDurations.length, \"Arrays length mismatch\");\n\n\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            tokenPriceFeeds[tokenAddresses[i]] = AggregatorV3Interface(priceFeedAddresses[i]);\n            tokenHeartbeatDurations[tokenAddresses[i]] = heartbeatDurations[i];\n        }\n    }\n\n    function addPriceFeed(address tokenAddress, address priceFeedAddress, uint256 heartbeatDuration) public onlyOwner {\n        require(priceFeedAddress != address(0), \"Invalid address\");\n        require(address(tokenPriceFeeds[tokenAddress]) == address(0), \"PriceFeed already exist\");\n        tokenPriceFeeds[tokenAddress] = AggregatorV3Interface(priceFeedAddress);\n        tokenHeartbeatDurations[tokenAddress] = heartbeatDuration;\n\n    }\n\n    function removePriceFeed(address tokenAddress) public onlyOwner {\n        require(address(tokenPriceFeeds[tokenAddress]) != address(0), \"PriceFeed already exist\");\n        delete tokenPriceFeeds[tokenAddress];\n        delete tokenHeartbeatDurations[tokenAddress];\n    }\n\n    function getTokenPrice(address tokenAddress) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n\n        (uint80 roundId, int256 answer, ,uint256 updatedAt  , ) = priceFeed.latestRoundData();\n\n        require(roundId != 0 && answer >= 0 && updatedAt != 0, \"PriceFeed: Sanity check\");\n\n        require(block.timestamp - updatedAt <= tokenHeartbeatDurations[tokenAddress], \"Price feed is stale\");\n        \n        // Token price might need additional scaling based on decimals\n        return uint256(answer);\n    }\n\n    function decimals(address tokenAddress) public view returns (uint8) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n        return priceFeed.decimals();\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}