{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/lifi/ICalldataVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICalldataVerificationFacet {\n\n    /// @notice Extracts the main parameters from the calldata\n    /// @param data The calldata to extract the main parameters from\n    /// @return bridge The bridge extracted from the calldata\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return amount The min amountfrom the calldata\n    /// @return destinationChainId The destination chain id extracted from the calldata\n    /// @return hasSourceSwaps Whether the calldata has source swaps\n    /// @return hasDestinationCall Whether the calldata has a destination call\n    function extractMainParameters(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            string memory bridge,\n            address sendingAssetId,\n            address receiver,\n            uint256 amount,\n            uint256 destinationChainId,\n            bool hasSourceSwaps,\n            bool hasDestinationCall\n        );\n\n    /// @notice Extracts the generic swap parameters from the calldata\n    /// @param data The calldata to extract the generic swap parameters from\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return amount The amount extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return receivingAssetId The receiving asset id extracted from the calldata\n    /// @return receivingAmount The receiving amount extracted from the calldata\n    function extractGenericSwapParameters(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            address sendingAssetId,\n            uint256 amount,\n            address receiver,\n            address receivingAssetId,\n            uint256 receivingAmount\n        );\n}"
    },
    "contracts/interfaces/vaults/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/**\n * @dev Interface of the Plugin standard.\n */\ninterface IPlugin {\n    enum ActionType {\n        // Action types\n        Stake,\n        Unstake,\n        SwapTokens,\n        ClaimRewards,\n        CancelAction\n    }\n\n    function execute(ActionType _actionType, bytes calldata _payload) external payable;\n    \n    function getTotalLiquidity() external view returns (uint256);\n\n    function getPoolNumber() external view returns(uint256);\n\n    function getAllowedTokens(uint8 _poolId) external view returns (address[] memory tokens);\n\n    function getPoolTokenPrice(uint8 _poolId, bool _maximize) external view returns (int256);\n\n    function getPoolTokenInfo(uint8 _poolId) external view returns (address token, uint8 decimal, uint256 balance);\n}\n"
    },
    "contracts/interfaces/vaults/IVaultLocker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n\ninterface IVaultLocker {\n    function getLockerStatus() external view returns(bool);\n}"
    },
    "contracts/vaults/theseus/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n// Libraries\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\n\n\nimport \"../../interfaces/vaults/IPlugin.sol\";\nimport \"../../interfaces/vaults/IVaultLocker.sol\";\nimport \"../../interfaces/lifi/ICalldataVerificationFacet.sol\";\nimport \"../TokenPriceConsumer.sol\";\n\n\ncontract Vault is Ownable, ERC20, ERC20Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constant representing the number of decimals for the MOZAIC token.\n    uint256 public constant MOZAIC_DECIMALS = 6;\n\n    // Constant representing the number of decimals for the ASSET.\n    uint256 public constant ASSET_DECIMALS = 36;\n\n    // A constant representing the denominator for basis points (BP). Used for percentage calculations.\n    uint256 public constant BP_DENOMINATOR = 1e4;\n\n    // A constant representing the maximum fee percentage allowed (1000 basis points or 10% in this case).\n    uint256 public constant MAX_FEE = 1e3;\n\n    // The Address of lifi contract\n    address public constant LIFI_CONTRACT = 0x1231DEB6f5749EF6cE6943a275A1D3E7486F4EaE;\n\n    // Struct defining the properties of a Plugin.\n    struct Plugin {\n        address pluginAddress;  // Address of the plugin contract.\n        uint8 pluginId;       // Unique identifier for the plugin.\n    }\n    \n    /* ========== STATE VARIABLES ========== */\n    // Stores the address of the master contract.\n    address public master;\n\n    // Stores the address of the contract admin.\n    address public admin;\n\n    // Stores the address of the treasury, which is payable for receiving funds.\n    address payable public treasury;\n\n    // Stores the address of the token price consumer contract.\n    address public tokenPriceConsumer;\n\n    // Maps plugin IDs to their respective index.\n    mapping(uint8 => uint256) public pluginIdToIndex;\n\n    // An array to store instances of the Plugin struct.\n    Plugin[] public plugins;\n\n    // Maps token addresses to boolean values indicating whether the token is accepted.\n    mapping(address => bool) public acceptedTokenMap;\n\n    // An array of accepted token addresses.\n    address[] public acceptedTokens;\n\n    // Maps token addresses to boolean values indicating whether deposits are allowed for the token.\n    mapping(address => bool) public depositAllowedTokenMap;\n\n    // An array of token addresses for which deposits are allowed.\n    address[] public depositAllowedTokens;\n\n    // Stores the ID of the currently selected plugin.\n    uint8 public selectedPluginId;\n\n    // Stores the ID of the currently selected pool.\n    uint8 public selectedPoolId;\n\n    // An array of addresses representing users who can lock assets in the vault.\n    address[] public vaultLockers;\n\n    // An array of addresses representing managers who have control over the vault.\n    address[] public vaultManagers;\n\n    // A rate used to convert LP (Liquidity Provider) tokens to a standard decimal format (18 decimals in this case).\n    uint256 public lpRate = 1e18;\n\n    // The percentage of fees collected by the protocol for each transaction.\n    uint256 public protocolFeePercentage;\n\n    // The total protocol fee held in the vault.\n    uint256 public protocolFeeInVault;\n\n    // The minimum execution fee required when depositing funds into the vault.\n    uint256 public depositMinExecFee;\n\n    // The minimum execution fee required when withdrawing funds from the vault.\n    uint256 public withdrawMinExecFee;\n\n    struct lifiWhiteListReceiver {\n        uint256 chainId;\n        bool isWhiteListed;\n    }\n    // The list of addresses that can receive funds from the vault via lifi bridge.\n    mapping(address => lifiWhiteListReceiver) public lifiReceiverWhiteList;\n\n\n    /* ========== EVENTS ========== */\n    event AddPlugin(uint8 _pluginId, address _pluginAddress);\n    event RemovePlugin(uint8 _pluginId);\n    event Execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes _payload);\n    event MasterUpdated(address _oldMaster, address _newMaster);\n    event AdminUpdated(address _oldAdmin, address _newAdmin);\n    event TokenPriceConsumerUpdated(address _oldTokenPriceConsumer, address _newTokenPriceConsumer);\n    event SetTreasury(address payable treasury);\n    event SetProtocolFeePercentage(uint256 _protocolFeePercentage);\n    event SetExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee);\n    event SetVaultLockers(address[] _vaultLockers);\n    event SetVaultManagers(address[] _vaultManagers);\n    event UpdateLiquidityProviderRate(uint256 _previousRate, uint256 _lpRate);\n    event AddAcceptedToken(address _token);\n    event RemoveAcceptedToken(address _token);\n    event AddDepositAllowedToken(address _token);\n    event RemoveDepositAllowedToken(address _token);\n    event AddDepositRequest(address _token, uint256 _amount);\n    event AddWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver);\n    event SelectPluginAndPool(uint8 _pluginId, uint8 _poolId);\n    event ApproveTokens(uint8 _pluginId, address[] _tokens, uint256[] _amounts);\n    event WithdrawProtocolFee(address _token, uint256 _amount);\n    event StakeToSelectedPool(uint8 _selectedPluginId, uint8 _selectedPoolId, address _token, uint256 _tokenAmount);\n    event SetLifiReceiverWhiteList(address _receiver, uint256 _chaindId, bool _status);\n\n\n    /* ========== MODIFIERS ========== */\n    // Modifier allowing only the master contract to execute the function.\n    modifier onlyMaster() {\n        require(msg.sender == master, \"Vault: caller must be master\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Vault: caller must be admin\");\n        _;\n    }\n\n\n    // Modifier allowing only the vault lockers to execute the function.\n    modifier onlyVaultLockers() {\n        bool isVaultLocker = false;\n        for(uint256 i  = 0; i < vaultLockers.length; i++) {\n            if(vaultLockers[i] == msg.sender) {\n                isVaultLocker = true;\n                break;\n            }\n        }\n        require(isVaultLocker, \"Vault: Invalid vault locker\");\n        _;\n    }\n\n    // Modifier allowing only the vault managers to execute the function.\n    modifier onlyVaultManagers() {\n        bool isVaultManager = false;\n        for(uint256 i  = 0; i < vaultManagers.length; i++) {\n            if(vaultManagers[i] == msg.sender) {\n                isVaultManager = true;\n                break;\n            }\n        }\n        require(isVaultManager, \"Vault: Invalid vault manager\");\n        _;\n    }\n\n    /* ========== CONFIGURATION ========== */\n    // Constructor for the Mozaic Theseus LPToken contract, inheriting from ERC20.\n    constructor(address _master,address _admin, address _tokenPriceConsumer, address payable _treasury) ERC20(\"Mozaic Theseus LP\", \"MOZ-THE-LP\") Ownable(msg.sender){\n        require(_master != address(0), \"Vault: Invalid Address\");\n        require(_admin != address(0), \"Vault: Invalid Address\");\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n        require(_treasury != address(0), \"Vault: Invalid Address\");\n\n        master = _master;\n        tokenPriceConsumer = _tokenPriceConsumer;\n        treasury = _treasury;\n        admin = _admin;\n\n        lifiReceiverWhiteList[address(this)] = lifiWhiteListReceiver(block.chainid, true);\n\n        lifiReceiverWhiteList[treasury] = lifiWhiteListReceiver(block.chainid, true);\n    }\n\n    // Allows the owner to set a new master address for the Vault.\n    function setMaster(address _newMaster) external onlyOwner {\n        // Ensure that the new master address is valid.\n        require(_newMaster != address(0), \"Vault: Invalid Address\");\n\n        // Store the current master address before updating.\n        address _oldMaster = master;\n\n        // Update the master address to the new value.\n        master = _newMaster;\n\n        // Emit an event to log the master address update.\n        emit MasterUpdated(_oldMaster, _newMaster);\n    }\n\n    // Allows the owner to set a new admin address for the Vault.\n    function setAdmin(address _newAdmin) external onlyOwner {\n        // Ensure that the new admin address is valid.\n        require(_newAdmin != address(0), \"Vault: Invalid Address\");\n\n        // Store the current admin address before updating.\n        address _oldAdmin = admin;\n\n        // Update the admin address to the new value.\n        admin = _newAdmin;\n\n        // Emit an event to log the admin address update.\n        emit MasterUpdated(_oldAdmin, _newAdmin);\n    }\n\n    // Allows the owner to set the address of the token price consumer contract.\n    function setTokenPriceConsumer(address _tokenPriceConsumer) public onlyOwner {\n        // Ensure that the new token price consumer address is valid.\n        require(_tokenPriceConsumer != address(0), \"Vault: Invalid Address\");\n\n        // Store the current token price consumer address before updating.\n        address _oldTokenPriceConsumer = tokenPriceConsumer;\n\n        // Update the token price consumer address to the new value.\n        tokenPriceConsumer = _tokenPriceConsumer;\n\n        // Emit an event to log the token price consumer address update.\n        emit TokenPriceConsumerUpdated(_oldTokenPriceConsumer, _tokenPriceConsumer);\n    }\n\n    // Allows the owner to set the address of the treasury.\n    function setTreasury(address payable _treasury) public onlyOwner {\n        // Ensure that the new treasury address is valid.\n        require(_treasury != address(0), \"Vault: Invalid address\");\n\n        // Update the treasury address to the new value.\n        treasury = _treasury;\n\n        // Emit an event to log the treasury address update.\n        emit SetTreasury(_treasury);\n    }\n\n    // Allows the owner to whitelist/remove from whitelist addresses that can receive funds from the vault via lifi bridge.\n    function setLifiReceiverWhiteList(address _receiver,uint256 _chaindId, bool _status) public onlyOwner {\n        lifiReceiverWhiteList[_receiver] = lifiWhiteListReceiver(_chaindId, _status);\n        emit SetLifiReceiverWhiteList(_receiver, _chaindId, _status);\n    }\n\n    // Allows the master contract to select a plugin and pool.\n    function selectPluginAndPool(uint8 _pluginId, uint8 _poolId) onlyAdmin public {\n        // Set the selectedPluginId and selectedPoolId to the provided values.\n        selectedPluginId = _pluginId;\n        selectedPoolId = _poolId;\n        emit SelectPluginAndPool(_pluginId, _poolId);\n    }\n\n    // Sets the execution fees for deposit and withdrawal transactions.\n    function setExecutionFee(uint256 _depositMinExecFee, uint256 _withdrawMinExecFee) public onlyAdmin {\n        // Set the deposit minimum execution fee\n        depositMinExecFee = _depositMinExecFee;\n\n        // Set the withdrawal minimum execution fee\n        withdrawMinExecFee = _withdrawMinExecFee;\n\n        // Emit an event to log the changes in execution fees\n        emit SetExecutionFee(_depositMinExecFee, _withdrawMinExecFee);\n    }\n\n\n    // Allows the owner to add a new accepted token.\n    function addAcceptedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == false) {\n            // Set the token as accepted, add it to the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = true;\n            acceptedTokens.push(_token);\n            emit AddAcceptedToken(_token);\n        } else {\n            // Revert if the token already exists in the accepted tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    // Allows the owner to remove an accepted token.\n    function removeAcceptedToken(address _token) external onlyOwner {\n        // Check if the token exists in the accepted tokens mapping.\n        if (acceptedTokenMap[_token] == true) {\n            // Set the token as not accepted, remove it from the acceptedTokens array, and emit an event.\n            acceptedTokenMap[_token] = false;\n            for (uint256 i = 0; i < acceptedTokens.length; ++i) {\n                if (acceptedTokens[i] == _token) {\n                    acceptedTokens[i] = acceptedTokens[acceptedTokens.length - 1];\n                    acceptedTokens.pop();\n                    emit RemoveAcceptedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the accepted tokens.\n        revert(\"Vault: Non-accepted token.\");\n    }\n\n    // Allows the owner to add a new deposit allowed token.\n    function addDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token does not already exist in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == false) {\n            // Set the token as allowed for deposit, add it to the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = true;\n            depositAllowedTokens.push(_token);\n            emit AddDepositAllowedToken(_token);\n        } else {\n            // Revert if the token already exists in the deposit allowed tokens.\n            revert(\"Vault: Token already exists.\");\n        }\n    }\n\n    // Allows the owner to remove a deposit allowed token.\n    function removeDepositAllowedToken(address _token) external onlyOwner {\n        // Check if the token exists in the deposit allowed tokens mapping.\n        if (depositAllowedTokenMap[_token] == true) {\n            // Set the token as not allowed for deposit, remove it from the depositAllowedTokens array, and emit an event.\n            depositAllowedTokenMap[_token] = false;\n            for (uint256 i = 0; i < depositAllowedTokens.length; ++i) {\n                if (depositAllowedTokens[i] == _token) {\n                    depositAllowedTokens[i] = depositAllowedTokens[depositAllowedTokens.length - 1];\n                    depositAllowedTokens.pop();\n                    emit RemoveDepositAllowedToken(_token);\n                    return;\n                }\n            }\n        }\n        // Revert if the token does not exist in the deposit allowed tokens.\n        revert(\"Vault: Non-deposit allowed token.\");\n    }\n\n    // Allows the owner to add a new plugin to the vault.\n    function addPlugin(uint8 _pluginId, address _pluginAddress) external onlyOwner {\n        // Ensure that the pluginId is not zero and does not already exist.\n        require(_pluginId != 0, \"Vault: PluginId cannot be zero\");\n        require(pluginIdToIndex[_pluginId] == 0, \"Plugin with this ID already exists\");\n\n        // Create a new Plugin instance and add it to the plugins array.\n        plugins.push(Plugin(_pluginAddress, _pluginId));\n        \n        // Update the mapping with the index of the added plugin.\n        pluginIdToIndex[_pluginId] = plugins.length;\n\n        // Emit an event to log the addition of a new plugin.\n        emit AddPlugin(_pluginId, _pluginAddress);\n    }\n\n    // Allows the owner to remove a plugin from the vault.\n    function removePlugin(uint8 _pluginId) external onlyOwner {\n        // Ensure that the pluginId exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Get the index of the plugin in the array.\n        uint256 pluginIndex = pluginIdToIndex[_pluginId] - 1;\n        \n        // Delete the mapping entry for the removed plugin.\n        delete pluginIdToIndex[_pluginId];\n\n        if (pluginIndex != plugins.length - 1) {\n            // If the removed plugin is not the last one, replace it with the last plugin in the array.\n            Plugin memory lastPlugin = plugins[plugins.length - 1];\n            plugins[pluginIndex] = lastPlugin;\n            pluginIdToIndex[lastPlugin.pluginId] = pluginIndex + 1;\n        }\n\n        // Remove the last element from the array.\n        plugins.pop();\n\n        // Emit an event to log the removal of a plugin.\n        emit RemovePlugin(_pluginId);\n    }\n\n    // Function to set the protocol fee percentage. Only callable by the owner of the contract.\n    function setProtocolFeePercentage(uint256 _protocolFeePercentage) external onlyOwner {\n        // Ensure that the provided protocol fee percentage does not exceed the maximum allowed fee.\n        require(_protocolFeePercentage <= MAX_FEE, \"Vault: protocol fee exceeds the max fee\");\n        \n        // Update the protocol fee percentage.\n        protocolFeePercentage = _protocolFeePercentage;\n\n        // Emit an event to log the change in protocol fee percentage.\n        emit SetProtocolFeePercentage(_protocolFeePercentage);\n    }\n\n    // Function to set the addresses of users who can lock assets in the vault. Only callable by the owner.\n    function setVaultLockers(address[] memory _vaultLockers) external onlyOwner {\n        // Update the array of vault lockers with the provided addresses.\n        vaultLockers = _vaultLockers;\n\n        // Emit an event to log the update of vault lockers with the provided addresses.\n        emit SetVaultLockers(_vaultLockers);\n    }\n\n    // Function to set the addresses of managers who have control over the vault. Only callable by the owner.\n    function setVaultManagers(address[] memory _vaultManagers) external onlyOwner {\n        // Update the array of vault managers with the provided addresses.\n        vaultManagers = _vaultManagers;\n\n        // Emit an event to log the update of vault managers with the provided addresses.\n        emit SetVaultManagers(_vaultManagers);\n\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n    \n    // Allows users to initiate a deposit request by converting tokens to LP tokens and staking them into the selected pool.\n    function addDepositRequest(address _token, uint256 _tokenAmount, address _receiver, bytes memory _payload) external payable nonReentrant whenNotPaused {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        require(msg.value >= depositMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure the deposited token is allowed for deposit in the vault.\n        require(isDepositAllowedToken(_token), \"Vault: Invalid token\");\n        \n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Ensure a valid and positive token amount is provided.\n        require(_tokenAmount > 0, \"Vault: Invalid token amount\");\n\n        // Calculate the USD value of the deposited tokens.\n        uint256 amountUsd = calculateTokenValueInUsd(_token, _tokenAmount);\n\n        require(amountUsd >= 10 ** (ASSET_DECIMALS - 2), \"Invalid token amount\");\n\n        // Convert the USD value to the corresponding LP token amount.\n        uint256 lpAmountToMint = convertAssetToLP(amountUsd);\n\n        // Ensure that there is a sufficient LP amount to mint.\n        require(lpAmountToMint > 0, \"Vault: Insufficient amount\");\n\n        // Transfer the deposited tokens from the user to the vault.\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _tokenAmount);\n\n        // Mint the calculated LP tokens and send them to the user.\n        _mint(_receiver, lpAmountToMint);\n\n        // Emit an event to log the deposit request.\n        emit AddDepositRequest(_token, _tokenAmount);\n\n        // Stake the minted LP tokens to the selected pool.\n        stakeToSelectedPool(_token, _tokenAmount, _payload);\n    }\n\n\n    // Internal function to stake a specified token amount to the selected pool using the configured plugin.\n    function stakeToSelectedPool(address _token, uint256 _tokenAmount, bytes memory _payload) internal {\n        // Retrieve the list of allowed tokens for the selected plugin and pool.\n        address[] memory allowedTokens = getTokensByPluginAndPoolId(selectedPluginId, selectedPoolId);\n\n        // Iterate through the allowed tokens to find the matching token.\n        for (uint256 i = 0; i < allowedTokens.length; i++) {\n            if (allowedTokens[i] == _token) {\n                // Create an array to represent token amounts, with the target token's amount set accordingly.\n                uint256[] memory _amounts = new uint256[](allowedTokens.length);\n                _amounts[i] = _tokenAmount;\n\n                // Encode the payload for the 'Stake' action using the selected plugin and pool.\n                bytes memory payload = abi.encode(uint8(selectedPoolId), allowedTokens, _amounts, _payload);\n\n                // Ensure that the specified plugin exists.\n                require(pluginIdToIndex[selectedPluginId] != 0, \"Plugin with this ID does not exist\");\n\n                // Retrieve the plugin address based on the provided plugin ID.\n                address plugin = plugins[pluginIdToIndex[selectedPluginId] - 1].pluginAddress;\n\n                // Increase the allowance for the plugin to spend the specified token amount.\n                IERC20(allowedTokens[i]).safeIncreaseAllowance(plugin, _tokenAmount);\n\n                // Execute the specified action on the plugin with the provided payload.\n                IPlugin(plugin).execute(IPlugin.ActionType.Stake, payload);\n                \n                emit StakeToSelectedPool(selectedPluginId, selectedPoolId, _token, _tokenAmount);\n                // Exit the function after successfully staking the token.\n                return;\n            }\n        }     \n        revert(\"Vault: deposit token not in allowedTokens\");\n    }\n\n    // Function to add a withdrawal request for a specified LP token amount from a selected pool using a specified plugin.\n    function addWithdrawalRequest(uint256 _lpAmount, uint8 _pluginId, uint8 _poolId, address _receiver, bytes memory payload) external payable whenNotPaused nonReentrant{\n        // Ensure that the vault is not locked before processing withdrawal requests.\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Ensure that the user has provided sufficient execution fee for the withdrawal.\n        require(msg.value >= withdrawMinExecFee, \"Vault: Insufficient execution fee\");\n\n        // Ensure a valid and positive LP token amount is provided for withdrawal.\n        require(_lpAmount > 0, \"Vault: Invalid LP token amount\");\n\n        // Update the current liquidity provider rate\n        updateLiquidityProviderRate();\n\n        // Transfer the specified amount of LP tokens from the user to the contract.\n        this.transferFrom(msg.sender, address(this), _lpAmount);\n\n        // Convert the LP token amount to its equivalent USD value.\n        uint256 usdAmountToWithdraw = convertLPToAsset(_lpAmount);\n\n        // Retrieve information about the selected pool token, including its decimals and price.\n        (, uint8 poolTokenDecimals, ) = getPoolTokenInfo(_pluginId, _poolId);\n\n        // Get the current price of the pool token.\n        uint256 poolTokenPrice = getPoolTokenPrice(_pluginId, _poolId);\n\n        // Calculate the amount of pool tokens equivalent to the USD value of the LP token withdrawal.\n        uint256 poolTokenAmount = convertDecimals(usdAmountToWithdraw, 6, poolTokenDecimals) / poolTokenPrice;\n\n        // Encode the payload for the 'Unstake' action using the specified pool and LP token details.\n        bytes memory _payload = abi.encode(_poolId, poolTokenAmount, _lpAmount, _receiver, payload);\n\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Execute the 'Unstake' action on the plugin with the provided payload.\n        IPlugin(plugin).execute(IPlugin.ActionType.Unstake, _payload);\n\n        emit AddWithdrawalRequest(_lpAmount, _pluginId, _poolId,  _receiver);\n    }\n\n    // Function to get the current price of the pool token for a specified pool using a specified plugin.\n    function getPoolTokenPrice(uint8 _pluginId, uint8 _poolId) public view returns (uint256) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token price.\n        int256 tokenPrice = IPlugin(plugin).getPoolTokenPrice(_poolId, true);\n\n        // Ensure that the retrieved token price is positive.\n        require(tokenPrice > 0, \"Vault: Pool token price is negative.\");\n\n        // Convert the token price to an unsigned integer and return it.\n        return uint256(tokenPrice);\n    }\n\n    // Function to get information about the pool token, including its address, decimals, and balance for a specified pool using a specified plugin.\n    function getPoolTokenInfo(uint8 _pluginId, uint8 _poolId) public view returns (address token, uint8 decimal, uint256 balance) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Call the external function on the specified plugin to get the pool token information.\n        return IPlugin(plugin).getPoolTokenInfo(_poolId);\n    }\n\n    \n    /* ========== MASTER FUNCTIONS ========== */\n    \n    // Allows the master contract to execute actions on a specified plugin.\n    function execute(uint8 _pluginId, IPlugin.ActionType _actionType, bytes memory _payload) public onlyMaster nonReentrant whenNotPaused{\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // If the action type is 'Stake', approve tokens for staking according to the payload.\n        if (_actionType == IPlugin.ActionType.Stake) {\n            (, address[] memory _tokens, uint256[] memory _amounts, ) = abi.decode(_payload, (uint8, address[], uint256[], bytes));\n            require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n            // Iterate through the tokens and approve them for staking.\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (_amounts[i] > 0) {\n                    IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n                }\n            }\n        } else if (_actionType == IPlugin.ActionType.Unstake) {\n            ( , , , address receiver, ) = abi.decode(_payload, (uint8, uint256, uint256, address, bytes));\n\n            // Ensure that the receiver address is the vault itself.\n            require(receiver == address(this), \"Invalid receiver\");\n        }\n\n        // Execute the specified action on the plugin with the provided payload.\n        IPlugin(plugin).execute(_actionType, _payload);\n\n        // Emit an event to log the execution of the plugin action.\n        emit Execute(_pluginId, _actionType, _payload);\n    }\n\n    // Allows the master contract to approve tokens for a specified plugin based on the provided payload.\n    function approveTokens(uint8 _pluginId, address[] memory _tokens, uint256[] memory _amounts) external onlyMaster nonReentrant whenNotPaused {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve the plugin address based on the provided plugin ID.\n        address plugin = plugins[pluginIdToIndex[_pluginId] - 1].pluginAddress;\n\n        // Decode the payload to obtain the list of tokens and corresponding amounts to approve.\n        // (address[] memory _tokens, uint256[] memory _amounts) = abi.decode(_payload, (address[], uint256[]));\n        require(_tokens.length == _amounts.length, \"Vault: Lists must have the same length\");\n\n        // Iterate through the tokens and approve them for the plugin.\n        for (uint256 i; i < _tokens.length; ++i) {\n            IERC20(_tokens[i]).safeIncreaseAllowance(plugin, _amounts[i]);\n        }\n        emit ApproveTokens(_pluginId, _tokens, _amounts);\n    }\n\n    // Updates the liquidity provider rate based on the current market rate.\n    function updateLiquidityProviderRate() internal {\n        // Store the previous liquidity provider rate\n        uint256 previousRate = lpRate;\n        \n        // Calculate the current liquidity provider rate from external source\n        uint256 currentRate = getCurrentLiquidityProviderRate();\n        \n        // Check if the current rate is higher than the previous rate\n        if (currentRate > previousRate) {\n            // Calculate the change in rate and update total profit\n            uint256 deltaRate = currentRate - previousRate;\n        \n            // Calculate total profit in the protocol's base asset\n            uint256 totalProfit = convertDecimals(deltaRate * totalSupply(), 18 + MOZAIC_DECIMALS, ASSET_DECIMALS);\n            \n            // Calculate protocol fee as a percentage of total profit\n            uint256 protocolFee = (totalProfit * protocolFeePercentage) / (BP_DENOMINATOR);\n            \n            // Accumulate protocol fee in the vault\n            protocolFeeInVault += protocolFee;\n\n            // Update the liquidity provider rate\n            lpRate = getCurrentLiquidityProviderRate();\n        } else {\n            // Update the liquidity provider rate directly\n            lpRate = currentRate;\n        }\n\n        // Emit an event to log the update in liquidity provider rate\n        emit UpdateLiquidityProviderRate(previousRate, lpRate);\n    }\n\n    // Withdraws protocol fees stored in the vault for a specific token.\n    function withdrawProtocolFee(address _token) external onlyMaster nonReentrant whenNotPaused {\n        require(isAcceptedToken(_token), \"Vault: Invalid token\");\n\n        // Calculate the token amount from the protocol fee in the vault\n        uint256 tokenAmount = calculateTokenAmountFromUsd(_token, protocolFeeInVault);\n\n        // Get the token balance of this contract\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n\n        // Determine the transfer amount, ensuring it doesn't exceed the token balance\n        uint256 transferAmount = tokenBalance >= tokenAmount ? tokenAmount : tokenBalance;\n\n        if(tokenAmount != 0) {        \n            // Update the protocol fee in the vault after the withdrawal\n            protocolFeeInVault = protocolFeeInVault - ((protocolFeeInVault * transferAmount) / (tokenAmount));\n\n            // Safely transfer the tokens to the treasury address\n            IERC20(_token).safeTransfer(treasury, transferAmount);\n        }\n        \n        // Emit an event to log the withdrawal\n        emit WithdrawProtocolFee(_token, transferAmount);\n    }\n\n    // Transfers the execution fee to the specified plugin.\n    function transferExecutionFee(uint8 _pluginId, uint256 _amount) external onlyMaster nonReentrant whenNotPaused {\n        // Retrieve information about the specified plugin\n        Plugin memory plugin = getPlugin(_pluginId);\n        \n        // Check if the contract has sufficient balance for the transfer\n        require(_amount <= address(this).balance, \"Vault: Insufficient balance\");\n        \n        // Attempt to transfer Ether to the plugin's address\n        (bool success, ) = plugin.pluginAddress.call{value: _amount}(\"\");\n        \n        // Revert if the Ether transfer to the plugin fails\n        require(success, \"Vault: Failed to send Ether\");\n    }\n \n     function bridgeViaLifi(\n        address _srcToken,\n        uint256 _amount,\n        uint256 _value,\n        bool _bridge,\n        bytes calldata _data\n    ) external onlyMaster nonReentrant {\n\n        if(_bridge) {\n            ( , , address receiver, , uint256 destinationChainId, , ) = ICalldataVerificationFacet(LIFI_CONTRACT).extractMainParameters(_data);\n            lifiWhiteListReceiver memory receiverInfo = lifiReceiverWhiteList[receiver];\n            require(receiverInfo.isWhiteListed &&  receiverInfo.chainId == destinationChainId, \"Vault: Lifi receiver not whitelisted\");\n        } else {\n            ( , , address receiver, , ) = ICalldataVerificationFacet(LIFI_CONTRACT).extractGenericSwapParameters(_data);\n            lifiWhiteListReceiver memory receiverInfo = lifiReceiverWhiteList[receiver];\n            require(receiverInfo.isWhiteListed && receiverInfo.chainId == block.chainid, \"Vault: Lifi receiver not whitelisted\");\n        }\n\n        bool isNative = (_srcToken == address(0));\n        if (!isNative) {           \n            uint256 currentAllowance = IERC20(_srcToken).allowance(address(this), address(LIFI_CONTRACT));\n            if (_amount > currentAllowance) {\n                uint256 increaseAmount = _amount - currentAllowance;\n                IERC20(_srcToken).safeIncreaseAllowance(address(LIFI_CONTRACT), increaseAmount);\n            } else if (_amount < currentAllowance) {\n                uint256 decreaseAmount = currentAllowance - _amount;\n                IERC20(_srcToken).safeDecreaseAllowance(address(LIFI_CONTRACT), decreaseAmount);\n            }\n        }\n        (bool success,) = LIFI_CONTRACT.call{value: _value}(_data);\n        require(success, \"Lifi: call failed\");\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // Retrieve the array of plugins registered in the vault.\n    function getPlugins() public view returns (Plugin[] memory) {\n        return plugins;\n    }\n\n    // Retrieve the total count of registered plugins in the vault.\n    function getPluginsCount() public view returns (uint256) {\n        return plugins.length;\n    }\n\n    // Retrieve details about a specific plugin based on its unique identifier.\n    function getPlugin(uint8 _pluginId) public view returns (Plugin memory) {\n        // Ensure that the specified plugin exists.\n        require(pluginIdToIndex[_pluginId] != 0, \"Plugin with this ID does not exist\");\n\n        // Retrieve and return details about the specified plugin.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n        return plugin;\n    }\n\n    // Retrieves the current liquidity provider rate.\n    function getCurrentLiquidityProviderRate() public view returns(uint256) {\n        uint256 _totalAssets = totalAssetInUsd() > protocolFeeInVault ? totalAssetInUsd() - protocolFeeInVault: 0;\n        \n        // Variable to store the current rate\n        uint256 currentRate;\n\n         // Check if total supply or total assets is zero\n        if (_totalAssets <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            currentRate = 1e18;\n        } else {\n            // Convert total assets to the desired decimals\n            uint256 adjustedAssets = convertDecimals(_totalAssets, ASSET_DECIMALS, MOZAIC_DECIMALS + 18);\n\n            // Calculate the current rate\n            currentRate = adjustedAssets / totalSupply();\n        }\n        return currentRate;\n    }\n\n    // Calculate the total value of assets held by the vault, including liquidity from registered plugins\n    // and the USD value of accepted tokens held in the vault.\n    function totalAssetInUsd() public view returns (uint256 _totalAsset) {\n        require(getVaultStatus() == true, \"Vault: Vault is locked\");\n\n        // Iterate through registered plugins to calculate their total liquidity.\n        for (uint8 i; i < plugins.length; ++i) {\n            _totalAsset += IPlugin(plugins[i].pluginAddress).getTotalLiquidity();\n        }\n\n        // Iterate through accepted tokens to calculate their total USD value.\n        for (uint256 i; i < acceptedTokens.length; ++i) {\n            // Calculate the USD value of the token based on its balance in the vault.\n            _totalAsset += calculateTokenValueInUsd(acceptedTokens[i], IERC20(acceptedTokens[i]).balanceOf(address(this)));\n        }\n\n        // Return the total calculated asset value.\n        return _totalAsset + 10 ** ASSET_DECIMALS;\n    }\n\n    // Check if a given token is accepted by the vault.\n    function isAcceptedToken(address _token) public view returns (bool) {\n        return acceptedTokenMap[_token];\n    }\n\n    // Check if a given token is allowed for deposit in the vault.\n    function isDepositAllowedToken(address _token) public view returns (bool) {\n        return depositAllowedTokenMap[_token];\n    }\n\n    function getAcceptedTokens() public view returns (address[] memory) {\n        return acceptedTokens;\n    }\n\n    function getDepositAllowedTokens() public view returns (address[] memory) {\n        return depositAllowedTokens;\n    }\n\n    // Retrieve the list of tokens allowed for a specific pool associated with a plugin.\n    // Returns an array of token addresses based on the provided plugin and pool IDs.\n    function getTokensByPluginAndPoolId(uint8 _pluginId, uint8 _poolId) public view returns (address[] memory) {\n        // Initialize an array to store the allowed tokens for the specified pool.\n        address[] memory poolAllowedTokens;\n\n        // If the specified plugin does not exist, return an empty array.\n        if (pluginIdToIndex[_pluginId] == 0) {\n            return poolAllowedTokens;\n        }\n\n        // Retrieve the plugin information based on the provided plugin ID.\n        Plugin memory plugin = plugins[pluginIdToIndex[_pluginId] - 1];\n\n        // Retrieve the allowed tokens for the specified pool from the associated plugin.\n        poolAllowedTokens = IPlugin(plugin.pluginAddress).getAllowedTokens(_poolId);\n\n        // Return the array of allowed tokens for the specified pool.\n        return poolAllowedTokens;\n    }\n\n    // Function to get the status of the vault, indicating whether it is locked or unlocked.\n    function getVaultStatus() public view returns (bool) {\n        // Initialize the status as true, assuming the vault is initially unlocked.\n        bool status = true;\n\n        // Iterate through the array of vault lockers to check their individual status.\n        for(uint256 i = 0; i < vaultLockers.length; i++) {\n            // Check the status of the current vault locker.\n            if(IVaultLocker(vaultLockers[i]).getLockerStatus() == false) {\n                // If any vault locker reports that it is locked, set the overall vault status to false and exit the loop.\n                status = false;\n                break;\n            }\n        }\n\n        // Return the overall status of the vault.\n        return status;\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    // Calculate the USD value of a given token amount based on its price and decimals.\n    function calculateTokenValueInUsd(address _tokenAddress, uint256 _tokenAmount) public view returns (uint256) {\n\n        if(_tokenAmount == 0) {\n            return 0;\n        }\n\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Retrieve the token price from the price consumer.\n        uint256 tokenPrice = TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        return convertDecimals(_tokenAmount * tokenPrice, tokenDecimals + priceConsumerDecimals, ASSET_DECIMALS);\n    }\n\n    // Calculate the token amount corresponding to a given USD value based on token price and decimals.\n    function calculateTokenAmountFromUsd(address _tokenAddress, uint256 _tokenValueUsd) public view returns (uint256) {\n        // Retrieve the token and price consumer decimals.\n        uint256 tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n        uint256 priceConsumerDecimals = TokenPriceConsumer(tokenPriceConsumer).decimals(_tokenAddress);\n\n        // Convert the USD value to the desired ASSET_DECIMALS.\n        uint256 normalizedValue = convertDecimals(_tokenValueUsd, ASSET_DECIMALS, tokenDecimals + priceConsumerDecimals);\n\n        // Calculate the token amount based on the normalized value and token price.\n        uint256 tokenAmount = normalizedValue / TokenPriceConsumer(tokenPriceConsumer).getTokenPrice(_tokenAddress);\n\n        // Return the calculated token amount.\n        return tokenAmount;\n    }\n\n    /* ========== CONVERT FUNCTIONS ========== */\n\n    // Convert an amount from one decimal precision to another.\n    function convertDecimals(uint256 _amount, uint256 _from, uint256 _to) public pure returns (uint256) {\n        // If the source decimal precision is greater than or equal to the target, perform division.\n        if (_from >= _to) {\n            return _amount / 10 ** (_from - _to);\n        } else {\n            // If the target decimal precision is greater than the source, perform multiplication.\n            return _amount * 10 ** (_to - _from);\n        }\n    }\n\n    // Convert an asset amount to LP tokens based on the current total asset and total LP token supply.\n    function convertAssetToLP(uint256 _amount) public view returns (uint256) {\n        // If the total asset is zero, perform direct decimal conversion.\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, ASSET_DECIMALS, MOZAIC_DECIMALS);\n        }\n        \n        // Perform conversion based on the proportion of the provided amount to the total asset.\n        return (_amount * totalSupply()) / _totalAssetInUsd;\n    }\n\n    // Convert LP tokens to an equivalent asset amount based on the current total asset and total LP token supply.\n    function convertLPToAsset(uint256 _amount) public view returns (uint256) {\n        uint256 _totalAssetInUsd = totalAssetInUsd() > protocolFeeInVault ?  totalAssetInUsd() - protocolFeeInVault : 0;\n\n        // If the total LP token supply is zero, perform direct decimal conversion.\n        if (_totalAssetInUsd <= 10 ** ASSET_DECIMALS || totalSupply() <= 10 ** MOZAIC_DECIMALS) {\n            return convertDecimals(_amount, MOZAIC_DECIMALS, ASSET_DECIMALS);\n        }\n        // Perform conversion based on the proportion of the provided amount to the total LP token supply.\n        return (_amount * _totalAssetInUsd) / totalSupply();\n    }\n\n    // Retrieve the decimal precision of the token (MOZAIC_DECIMALS).\n    function decimals() public view virtual override returns (uint8) {\n        return uint8(MOZAIC_DECIMALS);\n    }\n\n    // Function to get the total supply of the LP tokens, including an additional fixed supply represented by 10^MOZAIC_DECIMALS.\n    function totalSupply() public view virtual override returns (uint256) {\n        // Retrieve the original total supply from the parent contract and add an additional fixed supply.\n        return super.totalSupply() + 10 ** MOZAIC_DECIMALS;\n    }\n\n    // Function to burn a specified amount of LP tokens. Only callable by vault managers.\n    function burnLP(uint256 _lpAmount) external onlyVaultManagers {\n        // Burn the specified amount of LP tokens from the contract's balance.\n        _burn(address(this), _lpAmount);\n    }\n\n    // Function to transfer a specified amount of LP tokens to a given account. Only callable by vault managers.\n    function transferLP(address _account, uint256 _lpAmount) external onlyVaultManagers {\n        // Transfer the specified amount of LP tokens from the contract to the target account.\n        this.transfer(_account, _lpAmount);\n    }\n\n    /* ========== TREASURY FUNCTIONS ========== */\n    receive() external payable {}\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    /* ========== Pausable ========== */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable)\n    {\n        super._update(from, to, value);\n    }\n}"
    },
    "contracts/vaults/TokenPriceConsumer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\ncontract TokenPriceConsumer is Ownable {\n    mapping(address => AggregatorV3Interface) private tokenPriceFeeds;\n    \n    mapping(address => uint256) private tokenHeartbeatDurations;\n\n    constructor(address[] memory tokenAddresses, address[] memory priceFeedAddresses, uint256[] memory heartbeatDurations) Ownable(msg.sender) {\n        require(tokenAddresses.length == priceFeedAddresses.length, \"Arrays length mismatch\");\n        require(tokenAddresses.length == heartbeatDurations.length, \"Arrays length mismatch\");\n\n\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            tokenPriceFeeds[tokenAddresses[i]] = AggregatorV3Interface(priceFeedAddresses[i]);\n            tokenHeartbeatDurations[tokenAddresses[i]] = heartbeatDurations[i];\n        }\n    }\n\n    function addPriceFeed(address tokenAddress, address priceFeedAddress, uint256 heartbeatDuration) public onlyOwner {\n        require(priceFeedAddress != address(0), \"Invalid address\");\n        require(address(tokenPriceFeeds[tokenAddress]) == address(0), \"PriceFeed already exist\");\n        tokenPriceFeeds[tokenAddress] = AggregatorV3Interface(priceFeedAddress);\n        tokenHeartbeatDurations[tokenAddress] = heartbeatDuration;\n\n    }\n\n    function removePriceFeed(address tokenAddress) public onlyOwner {\n        require(address(tokenPriceFeeds[tokenAddress]) != address(0), \"PriceFeed already exist\");\n        delete tokenPriceFeeds[tokenAddress];\n        delete tokenHeartbeatDurations[tokenAddress];\n    }\n\n    function getTokenPrice(address tokenAddress) public view returns (uint256) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n\n        (uint80 roundId, int256 answer, ,uint256 updatedAt  , ) = priceFeed.latestRoundData();\n\n        require(roundId != 0 && answer >= 0 && updatedAt != 0, \"PriceFeed: Sanity check\");\n\n        require(block.timestamp - updatedAt <= tokenHeartbeatDurations[tokenAddress], \"Price feed is stale\");\n        \n        // Token price might need additional scaling based on decimals\n        return uint256(answer);\n    }\n\n    function decimals(address tokenAddress) public view returns (uint8) {\n        AggregatorV3Interface priceFeed = tokenPriceFeeds[tokenAddress];\n        require(address(priceFeed) != address(0), \"Price feed not found\");\n        return priceFeed.decimals();\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}